// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/socket.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace net {

class SocketControl;
class Connectivity;
struct NameLookup_LookupHostname_Response;
struct MacAddress;
class LookupIpOptions final {
public:
  constexpr LookupIpOptions() : value_(0u) {}
  explicit constexpr LookupIpOptions(uint8_t value) : value_(value) {}
  const static LookupIpOptions V4_ADDRS;
  const static LookupIpOptions V6_ADDRS;
  const static LookupIpOptions CNAME_LOOKUP;
  const static LookupIpOptions mask;

  explicit constexpr inline operator uint8_t() const { return value_; }
  constexpr inline operator bool() const { return value_; }
  constexpr inline LookupIpOptions operator~() const;
  constexpr inline LookupIpOptions operator|(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator&(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator^(const LookupIpOptions& other) const;
  constexpr inline void operator|=(const LookupIpOptions& other);
  constexpr inline void operator&=(const LookupIpOptions& other);
  constexpr inline void operator^=(const LookupIpOptions& other);

private:
  uint8_t value_;
};
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V4_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(1u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V6_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(2u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::CNAME_LOOKUP = ::llcpp::fuchsia::net::LookupIpOptions(4u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::mask = ::llcpp::fuchsia::net::LookupIpOptions(7u);

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator~() const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator|(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator&(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator^(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ ^ other.value_));
}

constexpr inline void LookupIpOptions::operator|=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ |= other.value_;
}

constexpr inline void LookupIpOptions::operator&=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ &= other.value_;
}

constexpr inline void LookupIpOptions::operator^=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ ^= other.value_;
}

enum class LookupError : uint32_t {
  NOT_FOUND = 1u,
  TRANSIENT = 2u,
  INVALID_ARGS = 3u,
  INTERNAL_ERROR = 4u,
};


struct NameLookup_LookupHostname_Result;
struct Ipv6Address;
struct Ipv4Address;
struct IpAddressInfo;
struct NameLookup_LookupIp_Response;
struct NameLookup_LookupIp_Result;
struct IpAddress;
struct Subnet;
class NameLookup;
struct Endpoint;
struct AddrStorage;
struct AddrInfo;
enum class AddrInfoStatus : uint32_t {
  ok = 0u,
  bad_flags = 1u,
  no_name = 2u,
  again = 3u,
  fail = 4u,
  no_data = 5u,
  buffer_overflow = 6u,
  system_error = 7u,
};


class SocketProvider;
struct AddrInfoHints;

extern "C" const fidl_type_t fuchsia_net_SocketControlBindRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlBindResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlConnectRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlConnectResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlListenRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlListenResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlAcceptResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlCloseResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlGetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketControlIoctlResponseTable;

// The control plane for a network socket. Once a socket has been retrieved from a
// `SocketProvider`, this interface is then used to further configure and use the socket.
// This interface is essentially POSIX. Its implementation must support Linux-specific arguments
// to {Get,Set}SockOpt.
class SocketControl final {
 public:

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    using ResponseType = ConnectResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = AcceptResponse;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = GetSockOptResponse;
  };

  struct IoctlResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
  };
  struct IoctlRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t req;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketControlIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    using ResponseType = IoctlResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Sets the local address used for the socket.
    zx_status_t Bind(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<BindResponse> Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets the local address used for the socket.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<BindResponse> Bind(::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a network endpoint.
    zx_status_t Connect(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ConnectResponse> Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ConnectResponse> Connect(::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    zx_status_t Listen(int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ListenResponse> Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ListenResponse> Listen(::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts an incoming connection from a network endpoint.
    zx_status_t Accept(int16_t flags, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AcceptResponse> Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AcceptResponse> Accept(::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

    // Closes the socket.
    zx_status_t Close(int16_t* out_code);

    // Closes the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart _response_buffer, int16_t* out_code);

    // Closes the socket.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the local socket address.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::fidl::BytePart response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::fidl::BytePart response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    zx_status_t SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the current value of a socket option. TODO(NET-1699): link to description of
    // supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Retrieves the current value of a socket option. TODO(NET-1699): link to description of
    // supported socket options.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Sets the local address used for the socket.
    static zx_status_t Bind(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<BindResponse> Bind(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets the local address used for the socket.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<BindResponse> Bind(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a network endpoint.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ConnectResponse> Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ConnectResponse> Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    static zx_status_t Listen(zx::unowned_channel _client_end, int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ListenResponse> Listen(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ListenResponse> Listen(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts an incoming connection from a network endpoint.
    static zx_status_t Accept(zx::unowned_channel _client_end, int16_t flags, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AcceptResponse> Accept(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AcceptResponse> Accept(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

    // Closes the socket.
    static zx_status_t Close(zx::unowned_channel _client_end, int16_t* out_code);

    // Closes the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Closes the socket.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the local socket address.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    static zx_status_t SetSockOpt(zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Retrieves the current value of a socket option. TODO(NET-1699): link to description of
    // supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Retrieves the current value of a socket option. TODO(NET-1699): link to description of
    // supported socket options.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = SocketControl;
    using _Base = ::fidl::CompleterBase;

    class BindCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(int16_t req, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_net_ConnectivityOnNetworkReachableEventTable;

class Connectivity final {
 public:
  static constexpr char Name_[] = "fuchsia.net.Connectivity";

  struct OnNetworkReachableResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool reachable;

    static constexpr const fidl_type_t* Type = &fuchsia_net_ConnectivityOnNetworkReachableEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct EventHandlers {
    // This is triggered on a state change in network reachability. Clients
    // should expect that network requests will succeed when `reachable` is
    // true.
    fit::function<zx_status_t(bool reachable)> on_network_reachable;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::function<zx_status_t()> unknown;
  };

  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Connectivity;
    using _Base = ::fidl::CompleterBase;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Messages are encoded in-place.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnNetworkReachableResponse> params);

};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResponseTable;

struct NameLookup_LookupHostname_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;

  ::fidl::StringView hostname{};
};



// A MAC address used to identify a network interface on the data link layer within the network.
struct MacAddress {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 6> octets{};
};

constexpr uint64_t MAX_HOSTNAME_SIZE = 255u;

constexpr uint64_t MAX_BUFFER = 900u;

constexpr uint64_t MAX_ADDR = 128u;

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResultTable;

struct NameLookup_LookupHostname_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NameLookup_LookupHostname_Result();
  ~NameLookup_LookupHostname_Result();

  NameLookup_LookupHostname_Result(NameLookup_LookupHostname_Result&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupHostname_Result& operator=(NameLookup_LookupHostname_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_response() const { return tag_ == Tag::kResponse; }

  NameLookup_LookupHostname_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupHostname_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupHostname_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  NameLookup_LookupHostname_Response const & response() const { return response_; }

  bool is_err() const { return tag_ == Tag::kErr; }

  LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  LookupError const & err() const { return err_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;

 private:
  void Destroy();
  void MoveImpl_(NameLookup_LookupHostname_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    NameLookup_LookupHostname_Response response_;
    LookupError err_;
  };
};



// Ipv6Address is expressed in network byte order, so the most significant byte
// ("ff" in the address "ff02::1") will be at index 0.
struct Ipv6Address {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 16> addr{};
};



// Ipv4Address is expressed in network byte order, so the most significant byte
// ("127" in the address "127.0.0.1") will be at index 0.
struct Ipv4Address {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 4> addr{};
};

extern "C" const fidl_type_t fuchsia_net_IpAddressInfoTable;

struct IpAddressInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  // All of the IPv4 addresses for the requested hostname.
  ::fidl::VectorView<Ipv4Address> ipv4_addrs{};

  // All of the IPv6 addresses for the requested hostname.
  ::fidl::VectorView<Ipv6Address> ipv6_addrs{};

  // The canonical name of the requested hostname (usually the DNS CNAME record, if one exists).
  ::fidl::StringView canonical_name{};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResponseTable;

struct NameLookup_LookupIp_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  IpAddressInfo addr{};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResultTable;

struct NameLookup_LookupIp_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NameLookup_LookupIp_Result();
  ~NameLookup_LookupIp_Result();

  NameLookup_LookupIp_Result(NameLookup_LookupIp_Result&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupIp_Result& operator=(NameLookup_LookupIp_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_response() const { return tag_ == Tag::kResponse; }

  NameLookup_LookupIp_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupIp_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupIp_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  NameLookup_LookupIp_Response const & response() const { return response_; }

  bool is_err() const { return tag_ == Tag::kErr; }

  LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  LookupError const & err() const { return err_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

 private:
  void Destroy();
  void MoveImpl_(NameLookup_LookupIp_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    NameLookup_LookupIp_Response response_;
    LookupError err_;
  };
};

extern "C" const fidl_type_t fuchsia_net_IpAddressTable;

// Represents an IP address that may be either v4 or v6.
struct IpAddress {
  enum class Tag : fidl_union_tag_t {
    kIpv4 = 0,
    kIpv6 = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  IpAddress();
  ~IpAddress();

  IpAddress(IpAddress&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  IpAddress& operator=(IpAddress&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_ipv4() const { return tag_ == Tag::kIpv4; }

  Ipv4Address& mutable_ipv4();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv4Address>::value && std::is_copy_assignable<T>::value>
  set_ipv4(const T& v) {
    mutable_ipv4() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv4Address>::value && std::is_move_assignable<T>::value>
  set_ipv4(T&& v) {
    mutable_ipv4() = std::move(v);
  }

  Ipv4Address const & ipv4() const { return ipv4_; }

  bool is_ipv6() const { return tag_ == Tag::kIpv6; }

  Ipv6Address& mutable_ipv6();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv6Address>::value && std::is_copy_assignable<T>::value>
  set_ipv6(const T& v) {
    mutable_ipv6() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv6Address>::value && std::is_move_assignable<T>::value>
  set_ipv6(T&& v) {
    mutable_ipv6() = std::move(v);
  }

  Ipv6Address const & ipv6() const { return ipv6_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(IpAddress&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    Ipv4Address ipv4_;
    Ipv6Address ipv6_;
  };
};

extern "C" const fidl_type_t fuchsia_net_SubnetTable;

// Subnet describes an IP subnetwork, where all host IP addresses share the same most significant
// bits.
struct Subnet {
  static constexpr const fidl_type_t* Type = &fuchsia_net_SubnetTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The Ipv4 or Ipv6 address. Only the `prefix_len` most significant bits may be set in `addr`;
  // all bits in the host portion of the address must be zero.
  IpAddress addr{};

  // The prefix length of the netmask. E.g. for 192.168.1.0/24, the prefix
  // length is 24, corresponding to a netmask of 255.255.255.0.
  // For Ipv4, prefix_len must be in the range [0, 32].
  // For Ipv6, prefix_len must be in the range [0, 128].
  uint8_t prefix_len{};
};

extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpResponseTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameResponseTable;

class NameLookup final {
 public:
  static constexpr char Name_[] = "fuchsia.net.NameLookup";

  struct LookupIpResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NameLookup_LookupIp_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
  };
  struct LookupIpRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView hostname;
    LookupIpOptions options;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
    using ResponseType = LookupIpResponse;
  };

  struct LookupHostnameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NameLookup_LookupHostname_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
  };
  struct LookupHostnameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    IpAddress addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = LookupHostnameResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }


    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<LookupIpResponse> LookupIp(::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer, NameLookup_LookupIp_Result* out_result);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<LookupIpResponse> LookupIp(::fidl::DecodedMessage<LookupIpRequest> params, ::fidl::BytePart response_buffer);


    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer, NameLookup_LookupHostname_Result* out_result);

    // Look up a hostname by IP address.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(::fidl::DecodedMessage<LookupHostnameRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:


    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<LookupIpResponse> LookupIp(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer, NameLookup_LookupIp_Result* out_result);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<LookupIpResponse> LookupIp(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupIpRequest> params, ::fidl::BytePart response_buffer);


    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer, NameLookup_LookupHostname_Result* out_result);

    // Look up a hostname by IP address.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupHostnameRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = NameLookup;
    using _Base = ::fidl::CompleterBase;

    class LookupIpCompleterBase : public _Base {
     public:
      void Reply(NameLookup_LookupIp_Result result);
      void Reply(::fidl::BytePart _buffer, NameLookup_LookupIp_Result result);
      void Reply(::fidl::DecodedMessage<LookupIpResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupIpCompleter = ::fidl::Completer<LookupIpCompleterBase>;

    virtual void LookupIp(::fidl::StringView hostname, LookupIpOptions options, LookupIpCompleter::Sync _completer) = 0;

    class LookupHostnameCompleterBase : public _Base {
     public:
      void Reply(NameLookup_LookupHostname_Result result);
      void Reply(::fidl::BytePart _buffer, NameLookup_LookupHostname_Result result);
      void Reply(::fidl::DecodedMessage<LookupHostnameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupHostnameCompleter = ::fidl::Completer<LookupHostnameCompleterBase>;

    virtual void LookupHostname(IpAddress addr, LookupHostnameCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_net_EndpointTable;

// Endpoint describes an IP address and port. The network protocol associated
// with the Endpoint will be known from context or communicated through
// additional structures.
struct Endpoint {
  static constexpr const fidl_type_t* Type = &fuchsia_net_EndpointTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The IP address of the endpoint.
  IpAddress addr{};

  // The port number of the endpoint.
  uint16_t port{};
};



struct AddrStorage {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 16> val{};

  uint32_t len{};
};

extern "C" const fidl_type_t fuchsia_net_AddrInfoTable;

struct AddrInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_net_AddrInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int32_t flags{};

  int32_t family{};

  int32_t sock_type{};

  int32_t protocol{};

  AddrStorage addr{};

  uint16_t port{};
};

extern "C" const fidl_type_t fuchsia_net_SocketProviderSocketRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketProviderSocketResponseTable;
extern "C" const fidl_type_t fuchsia_net_SocketProviderGetAddrInfoRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketProviderGetAddrInfoResponseTable;

// SocketProvider implements the POSIX sockets API.
class SocketProvider final {
 public:
  static constexpr char Name_[] = "fuchsia.net.SocketProvider";

  struct SocketResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::socket s;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderSocketResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SocketRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderSocketRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SocketResponse;
  };

  struct GetAddrInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    AddrInfoStatus status;
    uint32_t nres;
    ::fidl::Array<AddrInfo, 4> res;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderGetAddrInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 184;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct GetAddrInfoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView node;
    ::fidl::StringView service;
    AddrInfoHints* hints;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderGetAddrInfoRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 528;
    using ResponseType = GetAddrInfoResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    zx_status_t Socket(int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::socket* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SocketResponse> Socket(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::socket* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SocketResponse> Socket(::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    zx_status_t GetAddrInfo(::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo(::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo(::fidl::DecodedMessage<GetAddrInfoRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    static zx_status_t Socket(zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::socket* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SocketResponse> Socket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::socket* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SocketResponse> Socket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    static zx_status_t GetAddrInfo(zx::unowned_channel _client_end, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAddrInfoRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = SocketProvider;
    using _Base = ::fidl::CompleterBase;

    class SocketCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::socket s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::socket s);
      void Reply(::fidl::DecodedMessage<SocketResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SocketCompleter = ::fidl::Completer<SocketCompleterBase>;

    virtual void Socket(int16_t domain, int16_t type, int16_t protocol, SocketCompleter::Sync _completer) = 0;

    class GetAddrInfoCompleterBase : public _Base {
     public:
      void Reply(AddrInfoStatus status, uint32_t nres, ::fidl::Array<AddrInfo, 4> res);
      void Reply(::fidl::BytePart _buffer, AddrInfoStatus status, uint32_t nres, ::fidl::Array<AddrInfo, 4> res);
      void Reply(::fidl::DecodedMessage<GetAddrInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAddrInfoCompleter = ::fidl::Completer<GetAddrInfoCompleterBase>;

    virtual void GetAddrInfo(::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, GetAddrInfoCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct AddrInfoHints {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int32_t flags{};

  int32_t family{};

  int32_t sock_type{};

  int32_t protocol{};
};

}  // namespace net
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::BindRequest)
    == ::llcpp::fuchsia::net::SocketControl::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::BindResponse)
    == ::llcpp::fuchsia::net::SocketControl::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::BindResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::ConnectRequest)
    == ::llcpp::fuchsia::net::SocketControl::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::ConnectResponse)
    == ::llcpp::fuchsia::net::SocketControl::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::ConnectResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::ListenRequest)
    == ::llcpp::fuchsia::net::SocketControl::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::ListenResponse)
    == ::llcpp::fuchsia::net::SocketControl::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::ListenResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::AcceptRequest)
    == ::llcpp::fuchsia::net::SocketControl::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::AcceptResponse)
    == ::llcpp::fuchsia::net::SocketControl::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::AcceptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::CloseResponse)
    == ::llcpp::fuchsia::net::SocketControl::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::CloseResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::GetSockNameResponse)
    == ::llcpp::fuchsia::net::SocketControl::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse)
    == ::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetPeerNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::SetSockOptRequest)
    == ::llcpp::fuchsia::net::SocketControl::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::SetSockOptResponse)
    == ::llcpp::fuchsia::net::SocketControl::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::SetSockOptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::GetSockOptRequest)
    == ::llcpp::fuchsia::net::SocketControl::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::GetSockOptResponse)
    == ::llcpp::fuchsia::net::SocketControl::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockOptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::GetSockOptResponse, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::IoctlRequest)
    == ::llcpp::fuchsia::net::SocketControl::IoctlRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::IoctlRequest, req) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::IoctlRequest, in) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketControl::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketControl::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketControl::IoctlResponse)
    == ::llcpp::fuchsia::net::SocketControl::IoctlResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::IoctlResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketControl::IoctlResponse, out) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse)
    == ::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse, reachable) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response, hostname) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response) == ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::MacAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::MacAddress>);
static_assert(offsetof(::llcpp::fuchsia::net::MacAddress, octets) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::MacAddress) == ::llcpp::fuchsia::net::MacAddress::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::LookupIpOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::LookupIpOptions>);
static_assert(sizeof(::llcpp::fuchsia::net::LookupIpOptions) == sizeof(uint8_t));

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv6Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv6Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv6Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv6Address) == ::llcpp::fuchsia::net::Ipv6Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv4Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv4Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv4Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv4Address) == ::llcpp::fuchsia::net::Ipv4Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddressInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddressInfo>);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv4_addrs) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv6_addrs) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, canonical_name) == 32);
static_assert(sizeof(::llcpp::fuchsia::net::IpAddressInfo) == ::llcpp::fuchsia::net::IpAddressInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response) == ::llcpp::fuchsia::net::NameLookup_LookupIp_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddress>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Subnet> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Subnet>);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, prefix_len) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Subnet) == ::llcpp::fuchsia::net::Subnet::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, hostname) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, options) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Endpoint> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Endpoint>);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, port) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Endpoint) == ::llcpp::fuchsia::net::Endpoint::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrStorage> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrStorage>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrStorage, val) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrStorage, len) == 16);
static_assert(sizeof(::llcpp::fuchsia::net::AddrStorage) == ::llcpp::fuchsia::net::AddrStorage::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrInfo>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, flags) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, family) == 4);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, sock_type) == 8);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, protocol) == 12);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, addr) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, port) == 36);
static_assert(sizeof(::llcpp::fuchsia::net::AddrInfo) == ::llcpp::fuchsia::net::AddrInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::SocketRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::SocketRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::SocketRequest)
    == ::llcpp::fuchsia::net::SocketProvider::SocketRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::SocketRequest, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::SocketRequest, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::SocketRequest, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::SocketResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::SocketResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::SocketResponse)
    == ::llcpp::fuchsia::net::SocketProvider::SocketResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::SocketResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::SocketResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest)
    == ::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, node) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, service) == 32);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, hints) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse)
    == ::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, nres) == 20);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, res) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrInfoHints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrInfoHints>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, flags) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, family) == 4);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, sock_type) == 8);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, protocol) == 12);
static_assert(sizeof(::llcpp::fuchsia::net::AddrInfoHints) == ::llcpp::fuchsia::net::AddrInfoHints::PrimarySize);

}  // namespace fidl

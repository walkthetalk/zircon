// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/io/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace io {

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryWatcher_OnEvent_Ordinal = 546032797lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatcherOnEventRequestTable;

}  // namespace

zx_status_t DirectoryWatcher::SyncClient::OnEvent(::fidl::VectorView<uint8_t> events) {
  return DirectoryWatcher::Call::OnEvent(zx::unowned_channel(this->channel_), std::move(events));
}

zx_status_t DirectoryWatcher::Call::OnEvent(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnEventRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnEventRequest _request = {};
  _request._hdr.ordinal = kDirectoryWatcher_OnEvent_Ordinal;
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OnEventRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryWatcher::SyncClient::OnEvent(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events) {
  return DirectoryWatcher::Call::OnEvent(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events));
}

zx_status_t DirectoryWatcher::Call::OnEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events) {
  if (_request_buffer.capacity() < OnEventRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnEventRequest _request = {};
  _request._hdr.ordinal = kDirectoryWatcher_OnEvent_Ordinal;
  _request.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OnEventRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryWatcher::SyncClient::OnEvent(::fidl::DecodedMessage<OnEventRequest> params) {
  return DirectoryWatcher::Call::OnEvent(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t DirectoryWatcher::Call::OnEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnEventRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryWatcher_OnEvent_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


bool DirectoryWatcher::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDirectoryWatcher_OnEvent_Ordinal: {
      auto result = ::fidl::DecodeAs<OnEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnEvent(std::move(message->events),
        Interface::OnEventCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryWatcher::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


::llcpp::fuchsia::io::NodeInfo::NodeInfo() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::io::NodeInfo::~NodeInfo() {
  Destroy();
}

void ::llcpp::fuchsia::io::NodeInfo::Destroy() {
  switch (which()) {
  case Tag::kService:
    service_.~Service();
    break;
  case Tag::kFile:
    file_.~FileObject();
    break;
  case Tag::kDirectory:
    directory_.~DirectoryObject();
    break;
  case Tag::kPipe:
    pipe_.~Pipe();
    break;
  case Tag::kVmofile:
    vmofile_.~Vmofile();
    break;
  case Tag::kDevice:
    device_.~Device();
    break;
  case Tag::kTty:
    tty_.~Tty();
    break;
  case Tag::kSocket:
    socket_.~Socket();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::io::NodeInfo::MoveImpl_(NodeInfo&& other) {
  switch (other.which()) {
  case Tag::kService:
    mutable_service() = std::move(other.mutable_service());
    break;
  case Tag::kFile:
    mutable_file() = std::move(other.mutable_file());
    break;
  case Tag::kDirectory:
    mutable_directory() = std::move(other.mutable_directory());
    break;
  case Tag::kPipe:
    mutable_pipe() = std::move(other.mutable_pipe());
    break;
  case Tag::kVmofile:
    mutable_vmofile() = std::move(other.mutable_vmofile());
    break;
  case Tag::kDevice:
    mutable_device() = std::move(other.mutable_device());
    break;
  case Tag::kTty:
    mutable_tty() = std::move(other.mutable_tty());
    break;
  case Tag::kSocket:
    mutable_socket() = std::move(other.mutable_socket());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::io::NodeInfo::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, service_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, file_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, directory_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, pipe_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, vmofile_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, device_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, tty_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::io::NodeInfo, socket_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::io::NodeInfo) == ::llcpp::fuchsia::io::NodeInfo::PrimarySize);
}


Service& ::llcpp::fuchsia::io::NodeInfo::mutable_service() {
  if (which() != Tag::kService) {
    Destroy();
    new (&service_) Service;
  }
  tag_ = Tag::kService;
  return service_;
}

FileObject& ::llcpp::fuchsia::io::NodeInfo::mutable_file() {
  if (which() != Tag::kFile) {
    Destroy();
    new (&file_) FileObject;
  }
  tag_ = Tag::kFile;
  return file_;
}

DirectoryObject& ::llcpp::fuchsia::io::NodeInfo::mutable_directory() {
  if (which() != Tag::kDirectory) {
    Destroy();
    new (&directory_) DirectoryObject;
  }
  tag_ = Tag::kDirectory;
  return directory_;
}

Pipe& ::llcpp::fuchsia::io::NodeInfo::mutable_pipe() {
  if (which() != Tag::kPipe) {
    Destroy();
    new (&pipe_) Pipe;
  }
  tag_ = Tag::kPipe;
  return pipe_;
}

Vmofile& ::llcpp::fuchsia::io::NodeInfo::mutable_vmofile() {
  if (which() != Tag::kVmofile) {
    Destroy();
    new (&vmofile_) Vmofile;
  }
  tag_ = Tag::kVmofile;
  return vmofile_;
}

Device& ::llcpp::fuchsia::io::NodeInfo::mutable_device() {
  if (which() != Tag::kDevice) {
    Destroy();
    new (&device_) Device;
  }
  tag_ = Tag::kDevice;
  return device_;
}

Tty& ::llcpp::fuchsia::io::NodeInfo::mutable_tty() {
  if (which() != Tag::kTty) {
    Destroy();
    new (&tty_) Tty;
  }
  tag_ = Tag::kTty;
  return tty_;
}

Socket& ::llcpp::fuchsia::io::NodeInfo::mutable_socket() {
  if (which() != Tag::kSocket) {
    Destroy();
    new (&socket_) Socket;
  }
  tag_ = Tag::kSocket;
  return socket_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kNode_Clone_Ordinal = 402549324lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeCloneRequestTable;
[[maybe_unused]]
constexpr uint64_t kNode_Close_Ordinal = 1387878023lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Describe_Ordinal = 526573406lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_OnOpen_Ordinal = 1191225277lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kNode_Sync_Ordinal = 1648508842lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_GetAttr_Ordinal = 1166403528lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_SetAttr_Ordinal = 198530458lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Ioctl_Ordinal = 905161895lu << 32;
extern "C" const fidl_type_t fuchsia_io_NodeIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeIoctlResponseTable;

}  // namespace

zx_status_t Node::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return Node::Call::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

zx_status_t Node::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Node::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return Node::Call::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

zx_status_t Node::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Node::SyncClient::Clone(::fidl::DecodedMessage<CloneRequest> params) {
  return Node::Call::Clone(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Node::Call::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Clone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t Node::SyncClient::Close(int32_t* out_s) {
  return Node::Call::Close(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t Node::Call::Close(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Node::CloseResponse> Node::SyncClient::Close(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Node::Call::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Node::CloseResponse> Node::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<CloseRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_Close_Ordinal;
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Node::CloseResponse> Node::SyncClient::Close(::fidl::BytePart response_buffer) {
  return Node::Call::Close(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Node::CloseResponse> Node::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::CloseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::CloseResponse>());
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::CloseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::CloseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Node::SyncClient::Describe(NodeInfo* out_info) {
  return Node::Call::Describe(zx::unowned_channel(this->channel_), out_info);
}

zx_status_t Node::Call::Describe(zx::unowned_channel _client_end, NodeInfo* out_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_Describe_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return ZX_OK;
}

::fidl::DecodeResult<Node::DescribeResponse> Node::SyncClient::Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  return Node::Call::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_info);
}

::fidl::DecodeResult<Node::DescribeResponse> Node::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_Describe_Ordinal;
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return _decode_result;
}

::fidl::DecodeResult<Node::DescribeResponse> Node::SyncClient::Describe(::fidl::BytePart response_buffer) {
  return Node::Call::Describe(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Node::DescribeResponse> Node::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Describe_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::DescribeResponse>());
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::DescribeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Node::SyncClient::Sync(int32_t* out_s) {
  return Node::Call::Sync(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t Node::Call::Sync(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Node::SyncResponse> Node::SyncClient::Sync(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Node::Call::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Node::SyncResponse> Node::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<SyncRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_Sync_Ordinal;
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Node::SyncResponse> Node::SyncClient::Sync(::fidl::BytePart response_buffer) {
  return Node::Call::Sync(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Node::SyncResponse> Node::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::SyncResponse>());
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::SyncResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Node::SyncClient::GetAttr(int32_t* out_s, NodeAttributes* out_attributes) {
  return Node::Call::GetAttr(zx::unowned_channel(this->channel_), out_s, out_attributes);
}

zx_status_t Node::Call::GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_GetAttr_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return ZX_OK;
}

::fidl::DecodeResult<Node::GetAttrResponse> Node::SyncClient::GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  return Node::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_attributes);
}

::fidl::DecodeResult<Node::GetAttrResponse> Node::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_GetAttr_Ordinal;
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return _decode_result;
}

::fidl::DecodeResult<Node::GetAttrResponse> Node::SyncClient::GetAttr(::fidl::BytePart response_buffer) {
  return Node::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Node::GetAttrResponse> Node::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_GetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::GetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::GetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Node::SyncClient::SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  return Node::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes), out_s);
}

zx_status_t Node::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kNode_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Node::SetAttrResponse> Node::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Node::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Node::SetAttrResponse> Node::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kNode_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Node::SetAttrResponse> Node::SyncClient::SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  return Node::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Node::SetAttrResponse> Node::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_SetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::SetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::SetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Node::IoctlResponse> Node::SyncClient::Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  return Node::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(opcode), std::move(max_out), std::move(handles), std::move(in), std::move(_response_buffer), out_s, out_handles, out_out);
}

::fidl::DecodeResult<Node::IoctlResponse> Node::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  if (_request_buffer.capacity() < IoctlRequest::PrimarySize) {
    return ::fidl::DecodeResult<IoctlResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  IoctlRequest _request = {};
  _request._hdr.ordinal = kNode_Ioctl_Ordinal;
  _request.opcode = std::move(opcode);
  _request.max_out = std::move(max_out);
  _request.handles = std::move(handles);
  _request.in = std::move(in);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<IoctlRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_handles = std::move(_response.handles);
  *out_out = std::move(_response.out);
  return _decode_result;
}

::fidl::DecodeResult<Node::IoctlResponse> Node::SyncClient::Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  return Node::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Node::IoctlResponse> Node::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Ioctl_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::IoctlResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Node::IoctlResponse>());
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::IoctlResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Node::IoctlResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Node::SyncClient::HandleEvents(Node::EventHandlers handlers) {
  return Node::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Node::Call::HandleEvents(zx::unowned_channel client_end,
                                            Node::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kNode_OnOpen_Ordinal: {
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Node::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kNode_Clone_Ordinal: {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
        Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kNode_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kNode_Describe_Ordinal: {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
        Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kNode_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kNode_GetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
        Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kNode_SetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
        Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kNode_Ioctl_Ordinal: {
      auto result = ::fidl::DecodeAs<IoctlRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Ioctl(std::move(message->opcode), std::move(message->max_out), std::move(message->handles), std::move(message->in),
        Interface::IoctlCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Node::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Node::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  _response._hdr.ordinal = kNode_Close_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void Node::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  _response._hdr.ordinal = kNode_Close_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void Node::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Close_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::DescribeCompleterBase::Reply(NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  _response._hdr.ordinal = kNode_Describe_Ordinal;
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  _response._hdr.ordinal = kNode_Describe_Ordinal;
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Describe_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kNode_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kNode_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_OnOpen_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Node::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kNode_Sync_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  _response._hdr.ordinal = kNode_Sync_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Sync_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::GetAttrCompleterBase::Reply(int32_t s, NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kNode_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void Node::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kNode_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void Node::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_GetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kNode_SetAttr_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void Node::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kNode_SetAttr_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void Node::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_SetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::IoctlCompleterBase::Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IoctlResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  IoctlResponse _response = {};
  _response._hdr.ordinal = kNode_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Node::Interface::IoctlCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  if (_buffer.capacity() < IoctlResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  IoctlResponse _response = {};
  _response._hdr.ordinal = kNode_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Node::Interface::IoctlCompleterBase::Reply(::fidl::DecodedMessage<IoctlResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kNode_Ioctl_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kFile_Clone_Ordinal = 402549324lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileCloneRequestTable;
[[maybe_unused]]
constexpr uint64_t kFile_Close_Ordinal = 1387878023lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Describe_Ordinal = 526573406lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_OnOpen_Ordinal = 1191225277lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kFile_Sync_Ordinal = 1648508842lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetAttr_Ordinal = 1166403528lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_SetAttr_Ordinal = 198530458lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Ioctl_Ordinal = 905161895lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileIoctlResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Read_Ordinal = 636961156lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileReadResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_ReadAt_Ordinal = 2087865796lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileReadAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Write_Ordinal = 85125024lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileWriteRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_WriteAt_Ordinal = 1045766885lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileWriteAtRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Seek_Ordinal = 2016048965lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileSeekRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSeekResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Truncate_Ordinal = 1118517818lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileTruncateResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetFlags_Ordinal = 1679205366lu << 32;
[[maybe_unused]]
constexpr uint64_t kFile_SetFlags_Ordinal = 1059310710lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetBuffer_Ordinal = 1958938995lu << 32;
extern "C" const fidl_type_t fuchsia_io_FileGetBufferRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileGetBufferResponseTable;

}  // namespace

zx_status_t File::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return File::Call::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

zx_status_t File::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t File::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return File::Call::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

zx_status_t File::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t File::SyncClient::Clone(::fidl::DecodedMessage<CloneRequest> params) {
  return File::Call::Clone(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t File::Call::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Clone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t File::SyncClient::Close(int32_t* out_s) {
  return File::Call::Close(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t File::Call::Close(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<File::CloseResponse> File::SyncClient::Close(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return File::Call::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<File::CloseResponse> File::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<CloseRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Close_Ordinal;
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<File::CloseResponse> File::SyncClient::Close(::fidl::BytePart response_buffer) {
  return File::Call::Close(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<File::CloseResponse> File::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::CloseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::CloseResponse>());
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::CloseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::CloseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::Describe(NodeInfo* out_info) {
  return File::Call::Describe(zx::unowned_channel(this->channel_), out_info);
}

zx_status_t File::Call::Describe(zx::unowned_channel _client_end, NodeInfo* out_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Describe_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return ZX_OK;
}

::fidl::DecodeResult<File::DescribeResponse> File::SyncClient::Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  return File::Call::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_info);
}

::fidl::DecodeResult<File::DescribeResponse> File::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Describe_Ordinal;
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return _decode_result;
}

::fidl::DecodeResult<File::DescribeResponse> File::SyncClient::Describe(::fidl::BytePart response_buffer) {
  return File::Call::Describe(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<File::DescribeResponse> File::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Describe_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::DescribeResponse>());
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::DescribeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::Sync(int32_t* out_s) {
  return File::Call::Sync(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t File::Call::Sync(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<File::SyncResponse> File::SyncClient::Sync(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return File::Call::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<File::SyncResponse> File::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<SyncRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Sync_Ordinal;
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<File::SyncResponse> File::SyncClient::Sync(::fidl::BytePart response_buffer) {
  return File::Call::Sync(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<File::SyncResponse> File::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::SyncResponse>());
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::SyncResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::GetAttr(int32_t* out_s, NodeAttributes* out_attributes) {
  return File::Call::GetAttr(zx::unowned_channel(this->channel_), out_s, out_attributes);
}

zx_status_t File::Call::GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_GetAttr_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return ZX_OK;
}

::fidl::DecodeResult<File::GetAttrResponse> File::SyncClient::GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  return File::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_attributes);
}

::fidl::DecodeResult<File::GetAttrResponse> File::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_GetAttr_Ordinal;
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return _decode_result;
}

::fidl::DecodeResult<File::GetAttrResponse> File::SyncClient::GetAttr(::fidl::BytePart response_buffer) {
  return File::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<File::GetAttrResponse> File::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::GetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::GetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  return File::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes), out_s);
}

zx_status_t File::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<File::SetAttrResponse> File::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return File::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<File::SetAttrResponse> File::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<File::SetAttrResponse> File::SyncClient::SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::SetAttrResponse> File::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_SetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::SetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::SetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<File::IoctlResponse> File::SyncClient::Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  return File::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(opcode), std::move(max_out), std::move(handles), std::move(in), std::move(_response_buffer), out_s, out_handles, out_out);
}

::fidl::DecodeResult<File::IoctlResponse> File::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  if (_request_buffer.capacity() < IoctlRequest::PrimarySize) {
    return ::fidl::DecodeResult<IoctlResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  IoctlRequest _request = {};
  _request._hdr.ordinal = kFile_Ioctl_Ordinal;
  _request.opcode = std::move(opcode);
  _request.max_out = std::move(max_out);
  _request.handles = std::move(handles);
  _request.in = std::move(in);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<IoctlRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_handles = std::move(_response.handles);
  *out_out = std::move(_response.out);
  return _decode_result;
}

::fidl::DecodeResult<File::IoctlResponse> File::SyncClient::Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::IoctlResponse> File::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Ioctl_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::IoctlResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::IoctlResponse>());
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::IoctlResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::IoctlResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<File::ReadResponse> File::SyncClient::Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data) {
  return File::Call::Read(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(_response_buffer), out_s, out_data);
}

::fidl::DecodeResult<File::ReadResponse> File::Call::Read(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data) {
  if (_request_buffer.capacity() < ReadRequest::PrimarySize) {
    return ::fidl::DecodeResult<ReadResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<ReadRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Read_Ordinal;
  _request.count = std::move(count);
  _request_buffer.set_actual(sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ReadRequest, ReadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_data = std::move(_response.data);
  return _decode_result;
}

::fidl::DecodeResult<File::ReadResponse> File::SyncClient::Read(::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::Read(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::ReadResponse> File::Call::Read(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Read_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::ReadResponse>());
  }
  auto _call_result = ::fidl::Call<ReadRequest, ReadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::ReadResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<File::ReadAtResponse> File::SyncClient::ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data) {
  return File::Call::ReadAt(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(offset), std::move(_response_buffer), out_s, out_data);
}

::fidl::DecodeResult<File::ReadAtResponse> File::Call::ReadAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data) {
  if (_request_buffer.capacity() < ReadAtRequest::PrimarySize) {
    return ::fidl::DecodeResult<ReadAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<ReadAtRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_ReadAt_Ordinal;
  _request.count = std::move(count);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(ReadAtRequest));
  ::fidl::DecodedMessage<ReadAtRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadAtResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ReadAtRequest, ReadAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadAtResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_data = std::move(_response.data);
  return _decode_result;
}

::fidl::DecodeResult<File::ReadAtResponse> File::SyncClient::ReadAt(::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::ReadAt(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::ReadAtResponse> File::Call::ReadAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_ReadAt_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::ReadAtResponse>());
  }
  auto _call_result = ::fidl::Call<ReadAtRequest, ReadAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::ReadAtResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::Write(::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual) {
  return File::Call::Write(zx::unowned_channel(this->channel_), std::move(data), out_s, out_actual);
}

zx_status_t File::Call::Write(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WriteRequest _request = {};
  _request._hdr.ordinal = kFile_Write_Ordinal;
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WriteResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_actual = std::move(_response.actual);
  return ZX_OK;
}

::fidl::DecodeResult<File::WriteResponse> File::SyncClient::Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual) {
  return File::Call::Write(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(_response_buffer), out_s, out_actual);
}

::fidl::DecodeResult<File::WriteResponse> File::Call::Write(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual) {
  if (_request_buffer.capacity() < WriteRequest::PrimarySize) {
    return ::fidl::DecodeResult<WriteResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  WriteRequest _request = {};
  _request._hdr.ordinal = kFile_Write_Ordinal;
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_actual = std::move(_response.actual);
  return _decode_result;
}

::fidl::DecodeResult<File::WriteResponse> File::SyncClient::Write(::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::Write(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::WriteResponse> File::Call::Write(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Write_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::WriteResponse>());
  }
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::WriteResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual) {
  return File::Call::WriteAt(zx::unowned_channel(this->channel_), std::move(data), std::move(offset), out_s, out_actual);
}

zx_status_t File::Call::WriteAt(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WriteAtRequest _request = {};
  _request._hdr.ordinal = kFile_WriteAt_Ordinal;
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WriteAtRequest, WriteAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_actual = std::move(_response.actual);
  return ZX_OK;
}

::fidl::DecodeResult<File::WriteAtResponse> File::SyncClient::WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual) {
  return File::Call::WriteAt(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(offset), std::move(_response_buffer), out_s, out_actual);
}

::fidl::DecodeResult<File::WriteAtResponse> File::Call::WriteAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual) {
  if (_request_buffer.capacity() < WriteAtRequest::PrimarySize) {
    return ::fidl::DecodeResult<WriteAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  WriteAtRequest _request = {};
  _request._hdr.ordinal = kFile_WriteAt_Ordinal;
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteAtResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteAtResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WriteAtRequest, WriteAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WriteAtResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_actual = std::move(_response.actual);
  return _decode_result;
}

::fidl::DecodeResult<File::WriteAtResponse> File::SyncClient::WriteAt(::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::WriteAt(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::WriteAtResponse> File::Call::WriteAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_WriteAt_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::WriteAtResponse>());
  }
  auto _call_result = ::fidl::Call<WriteAtRequest, WriteAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::WriteAtResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::Seek(int64_t offset, SeekOrigin start, int32_t* out_s, uint64_t* out_offset) {
  return File::Call::Seek(zx::unowned_channel(this->channel_), std::move(offset), std::move(start), out_s, out_offset);
}

zx_status_t File::Call::Seek(zx::unowned_channel _client_end, int64_t offset, SeekOrigin start, int32_t* out_s, uint64_t* out_offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SeekRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Seek_Ordinal;
  _request.offset = std::move(offset);
  _request.start = std::move(start);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SeekResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SeekRequest, SeekResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_offset = std::move(_response.offset);
  return ZX_OK;
}

::fidl::DecodeResult<File::SeekResponse> File::SyncClient::Seek(::fidl::BytePart _request_buffer, int64_t offset, SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset) {
  return File::Call::Seek(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(offset), std::move(start), std::move(_response_buffer), out_s, out_offset);
}

::fidl::DecodeResult<File::SeekResponse> File::Call::Seek(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset) {
  if (_request_buffer.capacity() < SeekRequest::PrimarySize) {
    return ::fidl::DecodeResult<SeekResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SeekRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Seek_Ordinal;
  _request.offset = std::move(offset);
  _request.start = std::move(start);
  _request_buffer.set_actual(sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SeekResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SeekRequest, SeekResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SeekResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_offset = std::move(_response.offset);
  return _decode_result;
}

::fidl::DecodeResult<File::SeekResponse> File::SyncClient::Seek(::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::Seek(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::SeekResponse> File::Call::Seek(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Seek_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::SeekResponse>());
  }
  auto _call_result = ::fidl::Call<SeekRequest, SeekResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::SeekResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::Truncate(uint64_t length, int32_t* out_s) {
  return File::Call::Truncate(zx::unowned_channel(this->channel_), std::move(length), out_s);
}

zx_status_t File::Call::Truncate(zx::unowned_channel _client_end, uint64_t length, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TruncateRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<TruncateRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_Truncate_Ordinal;
  _request.length = std::move(length);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(TruncateRequest));
  ::fidl::DecodedMessage<TruncateRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<TruncateResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<TruncateRequest, TruncateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<File::TruncateResponse> File::SyncClient::Truncate(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return File::Call::Truncate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(length), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<File::TruncateResponse> File::Call::Truncate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < TruncateRequest::PrimarySize) {
    return ::fidl::DecodeResult<TruncateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<TruncateRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_Truncate_Ordinal;
  _request.length = std::move(length);
  _request_buffer.set_actual(sizeof(TruncateRequest));
  ::fidl::DecodedMessage<TruncateRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TruncateResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<TruncateRequest, TruncateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<TruncateResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<File::TruncateResponse> File::SyncClient::Truncate(::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::Truncate(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::TruncateResponse> File::Call::Truncate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Truncate_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::TruncateResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::TruncateResponse>());
  }
  auto _call_result = ::fidl::Call<TruncateRequest, TruncateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::TruncateResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::TruncateResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::GetFlags(int32_t* out_s, uint32_t* out_flags) {
  return File::Call::GetFlags(zx::unowned_channel(this->channel_), out_s, out_flags);
}

zx_status_t File::Call::GetFlags(zx::unowned_channel _client_end, int32_t* out_s, uint32_t* out_flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFlagsRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetFlagsRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_GetFlags_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFlagsRequest));
  ::fidl::DecodedMessage<GetFlagsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetFlagsRequest, GetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_flags = std::move(_response.flags);
  return ZX_OK;
}

::fidl::DecodeResult<File::GetFlagsResponse> File::SyncClient::GetFlags(::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags) {
  return File::Call::GetFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_flags);
}

::fidl::DecodeResult<File::GetFlagsResponse> File::Call::GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetFlagsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_GetFlags_Ordinal;
  _request_buffer.set_actual(sizeof(GetFlagsRequest));
  ::fidl::DecodedMessage<GetFlagsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetFlagsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetFlagsRequest, GetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetFlagsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_flags = std::move(_response.flags);
  return _decode_result;
}

::fidl::DecodeResult<File::GetFlagsResponse> File::SyncClient::GetFlags(::fidl::BytePart response_buffer) {
  return File::Call::GetFlags(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<File::GetFlagsResponse> File::Call::GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFlagsRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetFlagsRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetFlagsRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetFlags_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetFlagsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::GetFlagsResponse>());
  }
  auto _call_result = ::fidl::Call<GetFlagsRequest, GetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetFlagsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::GetFlagsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t File::SyncClient::SetFlags(uint32_t flags, int32_t* out_s) {
  return File::Call::SetFlags(zx::unowned_channel(this->channel_), std::move(flags), out_s);
}

zx_status_t File::Call::SetFlags(zx::unowned_channel _client_end, uint32_t flags, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFlagsRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetFlagsRequest*>(_write_bytes);
  _request._hdr.ordinal = kFile_SetFlags_Ordinal;
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFlagsRequest));
  ::fidl::DecodedMessage<SetFlagsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetFlagsRequest, SetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<File::SetFlagsResponse> File::SyncClient::SetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return File::Call::SetFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<File::SetFlagsResponse> File::Call::SetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < SetFlagsRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetFlagsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_SetFlags_Ordinal;
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(SetFlagsRequest));
  ::fidl::DecodedMessage<SetFlagsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetFlagsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetFlagsRequest, SetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetFlagsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<File::SetFlagsResponse> File::SyncClient::SetFlags(::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::SetFlags(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::SetFlagsResponse> File::Call::SetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_SetFlags_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetFlagsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::SetFlagsResponse>());
  }
  auto _call_result = ::fidl::Call<SetFlagsRequest, SetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SetFlagsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::SetFlagsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<File::GetBufferResponse> File::SyncClient::GetBuffer(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::mem::Buffer** out_buffer) {
  return File::Call::GetBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer), out_s, out_buffer);
}

::fidl::DecodeResult<File::GetBufferResponse> File::Call::GetBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::mem::Buffer** out_buffer) {
  if (_request_buffer.capacity() < GetBufferRequest::PrimarySize) {
    return ::fidl::DecodeResult<GetBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<GetBufferRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kFile_GetBuffer_Ordinal;
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(GetBufferRequest));
  ::fidl::DecodedMessage<GetBufferRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetBufferResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetBufferRequest, GetBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetBufferResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_buffer = std::move(_response.buffer);
  return _decode_result;
}

::fidl::DecodeResult<File::GetBufferResponse> File::SyncClient::GetBuffer(::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer) {
  return File::Call::GetBuffer(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<File::GetBufferResponse> File::Call::GetBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetBuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetBufferResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<File::GetBufferResponse>());
  }
  auto _call_result = ::fidl::Call<GetBufferRequest, GetBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetBufferResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<File::GetBufferResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t File::SyncClient::HandleEvents(File::EventHandlers handlers) {
  return File::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t File::Call::HandleEvents(zx::unowned_channel client_end,
                                            File::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kFile_OnOpen_Ordinal: {
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool File::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kFile_Clone_Ordinal: {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
        Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kFile_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kFile_Describe_Ordinal: {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
        Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kFile_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kFile_GetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
        Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kFile_SetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
        Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kFile_Ioctl_Ordinal: {
      auto result = ::fidl::DecodeAs<IoctlRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Ioctl(std::move(message->opcode), std::move(message->max_out), std::move(message->handles), std::move(message->in),
        Interface::IoctlCompleter::Sync(txn));
      return true;
    }
    case kFile_Read_Ordinal: {
      auto result = ::fidl::DecodeAs<ReadRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Read(std::move(message->count),
        Interface::ReadCompleter::Sync(txn));
      return true;
    }
    case kFile_ReadAt_Ordinal: {
      auto result = ::fidl::DecodeAs<ReadAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadAt(std::move(message->count), std::move(message->offset),
        Interface::ReadAtCompleter::Sync(txn));
      return true;
    }
    case kFile_Write_Ordinal: {
      auto result = ::fidl::DecodeAs<WriteRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Write(std::move(message->data),
        Interface::WriteCompleter::Sync(txn));
      return true;
    }
    case kFile_WriteAt_Ordinal: {
      auto result = ::fidl::DecodeAs<WriteAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteAt(std::move(message->data), std::move(message->offset),
        Interface::WriteAtCompleter::Sync(txn));
      return true;
    }
    case kFile_Seek_Ordinal: {
      auto result = ::fidl::DecodeAs<SeekRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Seek(std::move(message->offset), std::move(message->start),
        Interface::SeekCompleter::Sync(txn));
      return true;
    }
    case kFile_Truncate_Ordinal: {
      auto result = ::fidl::DecodeAs<TruncateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Truncate(std::move(message->length),
        Interface::TruncateCompleter::Sync(txn));
      return true;
    }
    case kFile_GetFlags_Ordinal: {
      auto result = ::fidl::DecodeAs<GetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetFlags(
        Interface::GetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_SetFlags_Ordinal: {
      auto result = ::fidl::DecodeAs<SetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetFlags(std::move(message->flags),
        Interface::SetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFile_GetBuffer_Ordinal: {
      auto result = ::fidl::DecodeAs<GetBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetBuffer(std::move(message->flags),
        Interface::GetBufferCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool File::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void File::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Close_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void File::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Close_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void File::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Close_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::DescribeCompleterBase::Reply(NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Describe_Ordinal;
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Describe_Ordinal;
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Describe_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kFile_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kFile_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_OnOpen_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void File::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Sync_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Sync_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Sync_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetAttrCompleterBase::Reply(int32_t s, NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void File::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void File::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_SetAttr_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void File::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_SetAttr_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void File::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_SetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::IoctlCompleterBase::Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IoctlResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  IoctlResponse _response = {};
  _response._hdr.ordinal = kFile_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::IoctlCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  if (_buffer.capacity() < IoctlResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  IoctlResponse _response = {};
  _response._hdr.ordinal = kFile_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::IoctlCompleterBase::Reply(::fidl::DecodedMessage<IoctlResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Ioctl_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadResponse _response = {};
  _response._hdr.ordinal = kFile_Read_Ordinal;
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data) {
  if (_buffer.capacity() < ReadResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadResponse _response = {};
  _response._hdr.ordinal = kFile_Read_Ordinal;
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::DecodedMessage<ReadResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Read_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadAtCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAtResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadAtResponse _response = {};
  _response._hdr.ordinal = kFile_ReadAt_Ordinal;
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data) {
  if (_buffer.capacity() < ReadAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadAtResponse _response = {};
  _response._hdr.ordinal = kFile_ReadAt_Ordinal;
  _response.s = std::move(s);
  _response.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::DecodedMessage<ReadAtResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_ReadAt_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteCompleterBase::Reply(int32_t s, uint64_t actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Write_Ordinal;
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteResponse>(std::move(_response_bytes)));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual) {
  if (_buffer.capacity() < WriteResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Write_Ordinal;
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  _buffer.set_actual(sizeof(WriteResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteResponse>(std::move(_buffer)));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::DecodedMessage<WriteResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Write_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteAtCompleterBase::Reply(int32_t s, uint64_t actual) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WriteAtResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_WriteAt_Ordinal;
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WriteAtResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAtResponse>(std::move(_response_bytes)));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual) {
  if (_buffer.capacity() < WriteAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WriteAtResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_WriteAt_Ordinal;
  _response.s = std::move(s);
  _response.actual = std::move(actual);
  _buffer.set_actual(sizeof(WriteAtResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WriteAtResponse>(std::move(_buffer)));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::DecodedMessage<WriteAtResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_WriteAt_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SeekCompleterBase::Reply(int32_t s, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SeekResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Seek_Ordinal;
  _response.s = std::move(s);
  _response.offset = std::move(offset);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SeekResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SeekResponse>(std::move(_response_bytes)));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t offset) {
  if (_buffer.capacity() < SeekResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SeekResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Seek_Ordinal;
  _response.s = std::move(s);
  _response.offset = std::move(offset);
  _buffer.set_actual(sizeof(SeekResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SeekResponse>(std::move(_buffer)));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::DecodedMessage<SeekResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Seek_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::TruncateCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TruncateResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<TruncateResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_Truncate_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(TruncateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TruncateResponse>(std::move(_response_bytes)));
}

void File::Interface::TruncateCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < TruncateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<TruncateResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_Truncate_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(TruncateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TruncateResponse>(std::move(_buffer)));
}

void File::Interface::TruncateCompleterBase::Reply(::fidl::DecodedMessage<TruncateResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_Truncate_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetFlagsResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_GetFlags_Ordinal;
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::GetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < GetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetFlagsResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_GetFlags_Ordinal;
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(GetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::GetFlagsCompleterBase::Reply(::fidl::DecodedMessage<GetFlagsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetFlags_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetFlagsResponse*>(_write_bytes);
  _response._hdr.ordinal = kFile_SetFlags_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFlagsResponse>(std::move(_response_bytes)));
}

void File::Interface::SetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetFlagsResponse*>(_buffer.data());
  _response._hdr.ordinal = kFile_SetFlags_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFlagsResponse>(std::move(_buffer)));
}

void File::Interface::SetFlagsCompleterBase::Reply(::fidl::DecodedMessage<SetFlagsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_SetFlags_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetBufferCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetBufferResponse _response = {};
  _response._hdr.ordinal = kFile_GetBuffer_Ordinal;
  _response.s = std::move(s);
  _response.buffer = std::move(buffer);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::GetBufferCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer) {
  if (_buffer.capacity() < GetBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetBufferResponse _response = {};
  _response._hdr.ordinal = kFile_GetBuffer_Ordinal;
  _response.s = std::move(s);
  _response.buffer = std::move(buffer);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::GetBufferCompleterBase::Reply(::fidl::DecodedMessage<GetBufferResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kFile_GetBuffer_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kDirectory_Clone_Ordinal = 402549324lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloneRequestTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Close_Ordinal = 1387878023lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Describe_Ordinal = 526573406lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_OnOpen_Ordinal = 1191225277lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Sync_Ordinal = 1648508842lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectorySyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetAttr_Ordinal = 1166403528lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_SetAttr_Ordinal = 198530458lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectorySetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectorySetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Ioctl_Ordinal = 905161895lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryIoctlResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Open_Ordinal = 2011483371lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryOpenRequestTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Unlink_Ordinal = 750443289lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_ReadDirents_Ordinal = 782580781lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryReadDirentsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rewind_Ordinal = 1886584199lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryRewindResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetToken_Ordinal = 840416493lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rename_Ordinal = 1251258540lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Link_Ordinal = 462052964lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Watch_Ordinal = 1522700084lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatchRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatchResponseTable;

}  // namespace

zx_status_t Directory::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return Directory::Call::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

zx_status_t Directory::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Directory::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return Directory::Call::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

zx_status_t Directory::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Directory::SyncClient::Clone(::fidl::DecodedMessage<CloneRequest> params) {
  return Directory::Call::Clone(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Directory::Call::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Clone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t Directory::SyncClient::Close(int32_t* out_s) {
  return Directory::Call::Close(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t Directory::Call::Close(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::CloseResponse> Directory::SyncClient::Close(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::CloseResponse> Directory::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<CloseRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Close_Ordinal;
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::CloseResponse> Directory::SyncClient::Close(::fidl::BytePart response_buffer) {
  return Directory::Call::Close(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::CloseResponse> Directory::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::CloseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::CloseResponse>());
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::CloseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::CloseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Describe(NodeInfo* out_info) {
  return Directory::Call::Describe(zx::unowned_channel(this->channel_), out_info);
}

zx_status_t Directory::Call::Describe(zx::unowned_channel _client_end, NodeInfo* out_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Describe_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::SyncClient::Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  return Directory::Call::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_info);
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Describe_Ordinal;
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return _decode_result;
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::SyncClient::Describe(::fidl::BytePart response_buffer) {
  return Directory::Call::Describe(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Describe_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::DescribeResponse>());
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::DescribeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Sync(int32_t* out_s) {
  return Directory::Call::Sync(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t Directory::Call::Sync(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::SyncClient::Sync(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<SyncRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Sync_Ordinal;
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::SyncClient::Sync(::fidl::BytePart response_buffer) {
  return Directory::Call::Sync(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::SyncResponse>());
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::SyncResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::GetAttr(int32_t* out_s, NodeAttributes* out_attributes) {
  return Directory::Call::GetAttr(zx::unowned_channel(this->channel_), out_s, out_attributes);
}

zx_status_t Directory::Call::GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_GetAttr_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::GetAttrResponse> Directory::SyncClient::GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  return Directory::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_attributes);
}

::fidl::DecodeResult<Directory::GetAttrResponse> Directory::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_GetAttr_Ordinal;
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return _decode_result;
}

::fidl::DecodeResult<Directory::GetAttrResponse> Directory::SyncClient::GetAttr(::fidl::BytePart response_buffer) {
  return Directory::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::GetAttrResponse> Directory::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_GetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::GetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::GetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  return Directory::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes), out_s);
}

zx_status_t Directory::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::SetAttrResponse> Directory::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::SetAttrResponse> Directory::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::SetAttrResponse> Directory::SyncClient::SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::SetAttrResponse> Directory::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_SetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::SetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::SetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Directory::IoctlResponse> Directory::SyncClient::Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  return Directory::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(opcode), std::move(max_out), std::move(handles), std::move(in), std::move(_response_buffer), out_s, out_handles, out_out);
}

::fidl::DecodeResult<Directory::IoctlResponse> Directory::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  if (_request_buffer.capacity() < IoctlRequest::PrimarySize) {
    return ::fidl::DecodeResult<IoctlResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  IoctlRequest _request = {};
  _request._hdr.ordinal = kDirectory_Ioctl_Ordinal;
  _request.opcode = std::move(opcode);
  _request.max_out = std::move(max_out);
  _request.handles = std::move(handles);
  _request.in = std::move(in);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<IoctlRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_handles = std::move(_response.handles);
  *out_out = std::move(_response.out);
  return _decode_result;
}

::fidl::DecodeResult<Directory::IoctlResponse> Directory::SyncClient::Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::IoctlResponse> Directory::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Ioctl_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::IoctlResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::IoctlResponse>());
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::IoctlResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::IoctlResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return Directory::Call::Open(zx::unowned_channel(this->channel_), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

zx_status_t Directory::Call::Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OpenRequest _request = {};
  _request._hdr.ordinal = kDirectory_Open_Ordinal;
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Directory::SyncClient::Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return Directory::Call::Open(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

zx_status_t Directory::Call::Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OpenRequest _request = {};
  _request._hdr.ordinal = kDirectory_Open_Ordinal;
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Directory::SyncClient::Open(::fidl::DecodedMessage<OpenRequest> params) {
  return Directory::Call::Open(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Directory::Call::Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Open_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t Directory::SyncClient::Unlink(::fidl::StringView path, int32_t* out_s) {
  return Directory::Call::Unlink(zx::unowned_channel(this->channel_), std::move(path), out_s);
}

zx_status_t Directory::Call::Unlink(zx::unowned_channel _client_end, ::fidl::StringView path, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  UnlinkRequest _request = {};
  _request._hdr.ordinal = kDirectory_Unlink_Ordinal;
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Unlink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::Call::Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    return ::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  UnlinkRequest _request = {};
  _request._hdr.ordinal = kDirectory_Unlink_Ordinal;
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::SyncClient::Unlink(::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::Unlink(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::Call::Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Unlink_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::UnlinkResponse>());
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::UnlinkResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Directory::ReadDirentsResponse> Directory::SyncClient::ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents) {
  return Directory::Call::ReadDirents(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer), out_s, out_dirents);
}

::fidl::DecodeResult<Directory::ReadDirentsResponse> Directory::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents) {
  if (_request_buffer.capacity() < ReadDirentsRequest::PrimarySize) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_ReadDirents_Ordinal;
  _request.max_bytes = std::move(max_bytes);
  _request_buffer.set_actual(sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_dirents = std::move(_response.dirents);
  return _decode_result;
}

::fidl::DecodeResult<Directory::ReadDirentsResponse> Directory::SyncClient::ReadDirents(::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::ReadDirents(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::ReadDirentsResponse> Directory::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_ReadDirents_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::ReadDirentsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::ReadDirentsResponse>());
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::ReadDirentsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::ReadDirentsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Rewind(int32_t* out_s) {
  return Directory::Call::Rewind(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t Directory::Call::Rewind(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<RewindRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Rewind_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::RewindResponse> Directory::SyncClient::Rewind(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Rewind(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::RewindResponse> Directory::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<RewindRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Rewind_Ordinal;
  _request_buffer.set_actual(sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RewindResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RewindResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::RewindResponse> Directory::SyncClient::Rewind(::fidl::BytePart response_buffer) {
  return Directory::Call::Rewind(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::RewindResponse> Directory::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(RewindRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<RewindRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Rewind_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RewindResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::RewindResponse>());
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RewindResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::RewindResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::GetToken(int32_t* out_s, ::zx::handle* out_token) {
  return Directory::Call::GetToken(zx::unowned_channel(this->channel_), out_s, out_token);
}

zx_status_t Directory::Call::GetToken(zx::unowned_channel _client_end, int32_t* out_s, ::zx::handle* out_token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetTokenRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_GetToken_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_token = std::move(_response.token);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::SyncClient::GetToken(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token) {
  return Directory::Call::GetToken(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_token);
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetTokenRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_GetToken_Ordinal;
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTokenResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTokenResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_token = std::move(_response.token);
  return _decode_result;
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::SyncClient::GetToken(::fidl::BytePart response_buffer) {
  return Directory::Call::GetToken(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_GetToken_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::GetTokenResponse>());
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::GetTokenResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  return Directory::Call::Rename(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst), out_s);
}

zx_status_t Directory::Call::Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  RenameRequest _request = {};
  _request._hdr.ordinal = kDirectory_Rename_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Rename(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::Call::Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    return ::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  RenameRequest _request = {};
  _request._hdr.ordinal = kDirectory_Rename_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::SyncClient::Rename(::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::Rename(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::Call::Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Rename_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::RenameResponse>());
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::RenameResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  return Directory::Call::Link(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst), out_s);
}

zx_status_t Directory::Call::Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  LinkRequest _request = {};
  _request._hdr.ordinal = kDirectory_Link_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Link(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::Call::Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    return ::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  LinkRequest _request = {};
  _request._hdr.ordinal = kDirectory_Link_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::SyncClient::Link(::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::Link(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::Call::Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Link_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::LinkResponse>());
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::LinkResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Directory::SyncClient::Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s) {
  return Directory::Call::Watch(zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher), out_s);
}

zx_status_t Directory::Call::Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<WatchRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectory_Watch_Ordinal;
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<Directory::WatchResponse> Directory::SyncClient::Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return Directory::Call::Watch(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<Directory::WatchResponse> Directory::Call::Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    return ::fidl::DecodeResult<WatchResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<WatchRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectory_Watch_Ordinal;
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  _request_buffer.set_actual(sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WatchResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WatchResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<Directory::WatchResponse> Directory::SyncClient::Watch(::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  return Directory::Call::Watch(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Directory::WatchResponse> Directory::Call::Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Watch_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::WatchResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Directory::WatchResponse>());
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::WatchResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Directory::WatchResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Directory::SyncClient::HandleEvents(Directory::EventHandlers handlers) {
  return Directory::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Directory::Call::HandleEvents(zx::unowned_channel client_end,
                                            Directory::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kDirectory_OnOpen_Ordinal: {
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Directory::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDirectory_Clone_Ordinal: {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
        Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Describe_Ordinal: {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
        Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
        Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectory_SetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
        Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Ioctl_Ordinal: {
      auto result = ::fidl::DecodeAs<IoctlRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Ioctl(std::move(message->opcode), std::move(message->max_out), std::move(message->handles), std::move(message->in),
        Interface::IoctlCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Open_Ordinal: {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->flags), std::move(message->mode), std::move(message->path), std::move(message->object),
        Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Unlink_Ordinal: {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
        Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_ReadDirents_Ordinal: {
      auto result = ::fidl::DecodeAs<ReadDirentsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadDirents(std::move(message->max_bytes),
        Interface::ReadDirentsCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Rewind_Ordinal: {
      auto result = ::fidl::DecodeAs<RewindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Rewind(
        Interface::RewindCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetToken_Ordinal: {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
        Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Rename_Ordinal: {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
        Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Link_Ordinal: {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
        Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Watch_Ordinal: {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
        Interface::WatchCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Directory::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Directory::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Close_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void Directory::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Close_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void Directory::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Close_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::DescribeCompleterBase::Reply(NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Describe_Ordinal;
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Describe_Ordinal;
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Describe_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kDirectory_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kDirectory_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_OnOpen_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void Directory::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Sync_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Sync_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Sync_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::GetAttrCompleterBase::Reply(int32_t s, NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void Directory::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void Directory::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_GetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_SetAttr_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void Directory::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_SetAttr_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void Directory::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_SetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::IoctlCompleterBase::Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IoctlResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  IoctlResponse _response = {};
  _response._hdr.ordinal = kDirectory_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::IoctlCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  if (_buffer.capacity() < IoctlResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  IoctlResponse _response = {};
  _response._hdr.ordinal = kDirectory_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::IoctlCompleterBase::Reply(::fidl::DecodedMessage<IoctlResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Ioctl_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::UnlinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Unlink_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_response_bytes)));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Unlink_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_buffer)));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Unlink_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::ReadDirentsCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadDirentsResponse _response = {};
  _response._hdr.ordinal = kDirectory_ReadDirents_Ordinal;
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::ReadDirentsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  if (_buffer.capacity() < ReadDirentsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadDirentsResponse _response = {};
  _response._hdr.ordinal = kDirectory_ReadDirents_Ordinal;
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::ReadDirentsCompleterBase::Reply(::fidl::DecodedMessage<ReadDirentsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_ReadDirents_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::RewindCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RewindResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Rewind_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_response_bytes)));
}

void Directory::Interface::RewindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RewindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RewindResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Rewind_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_buffer)));
}

void Directory::Interface::RewindCompleterBase::Reply(::fidl::DecodedMessage<RewindResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Rewind_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::GetTokenCompleterBase::Reply(int32_t s, ::zx::handle token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_GetToken_Ordinal;
  _response.s = std::move(s);
  _response.token = std::move(token);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_response_bytes)));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_GetToken_Ordinal;
  _response.s = std::move(s);
  _response.token = std::move(token);
  _buffer.set_actual(sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_buffer)));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_GetToken_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::RenameCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RenameResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Rename_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_response_bytes)));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RenameResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Rename_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_buffer)));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Rename_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::LinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LinkResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Link_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_response_bytes)));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LinkResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Link_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_buffer)));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Link_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::WatchCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WatchResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectory_Watch_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_response_bytes)));
}

void Directory::Interface::WatchCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < WatchResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WatchResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectory_Watch_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_buffer)));
}

void Directory::Interface::WatchCompleterBase::Reply(::fidl::DecodedMessage<WatchResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectory_Watch_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Clone_Ordinal = 402549324lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloneRequestTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Close_Ordinal = 1387878023lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Describe_Ordinal = 526573406lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_OnOpen_Ordinal = 1191225277lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Sync_Ordinal = 1648508842lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetAttr_Ordinal = 1166403528lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_SetAttr_Ordinal = 198530458lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Ioctl_Ordinal = 905161895lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminIoctlResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Open_Ordinal = 2011483371lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOpenRequestTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unlink_Ordinal = 750443289lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_ReadDirents_Ordinal = 782580781lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminReadDirentsResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rewind_Ordinal = 1886584199lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRewindResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetToken_Ordinal = 840416493lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Rename_Ordinal = 1251258540lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Link_Ordinal = 462052964lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Watch_Ordinal = 1522700084lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminWatchRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminWatchResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Mount_Ordinal = 2120159974lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_MountAndCreate_Ordinal = 841348753lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountAndCreateRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountAndCreateResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_Unmount_Ordinal = 620898132lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_UnmountNode_Ordinal = 383400103lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountNodeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_QueryFilesystem_Ordinal = 1713999250lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminQueryFilesystemResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectoryAdmin_GetDevicePath_Ordinal = 787943096lu << 32;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetDevicePathResponseTable;

}  // namespace

zx_status_t DirectoryAdmin::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
  return DirectoryAdmin::Call::Clone(zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

zx_status_t DirectoryAdmin::Call::Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return DirectoryAdmin::Call::Clone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

zx_status_t DirectoryAdmin::Call::Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Clone_Ordinal;
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::Clone(::fidl::DecodedMessage<CloneRequest> params) {
  return DirectoryAdmin::Call::Clone(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t DirectoryAdmin::Call::Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Clone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Close(int32_t* out_s) {
  return DirectoryAdmin::Call::Close(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t DirectoryAdmin::Call::Close(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::CloseResponse> DirectoryAdmin::SyncClient::Close(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Close(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::CloseResponse> DirectoryAdmin::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<CloseRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CloseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::CloseResponse> DirectoryAdmin::SyncClient::Close(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Close(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::CloseResponse> DirectoryAdmin::Call::Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::CloseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::CloseResponse>());
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::CloseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::CloseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Describe(NodeInfo* out_info) {
  return DirectoryAdmin::Call::Describe(zx::unowned_channel(this->channel_), out_info);
}

zx_status_t DirectoryAdmin::Call::Describe(zx::unowned_channel _client_end, NodeInfo* out_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::DescribeResponse> DirectoryAdmin::SyncClient::Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  return DirectoryAdmin::Call::Describe(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_info);
}

::fidl::DecodeResult<DirectoryAdmin::DescribeResponse> DirectoryAdmin::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DescribeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_info = std::move(_response.info);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::DescribeResponse> DirectoryAdmin::SyncClient::Describe(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Describe(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::DescribeResponse> DirectoryAdmin::Call::Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::DescribeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::DescribeResponse>());
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::DescribeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::DescribeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Sync(int32_t* out_s) {
  return DirectoryAdmin::Call::Sync(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t DirectoryAdmin::Call::Sync(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::SyncResponse> DirectoryAdmin::SyncClient::Sync(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Sync(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::SyncResponse> DirectoryAdmin::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<SyncRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SyncResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::SyncResponse> DirectoryAdmin::SyncClient::Sync(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Sync(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::SyncResponse> DirectoryAdmin::Call::Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SyncResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::SyncResponse>());
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SyncResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::SyncResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::GetAttr(int32_t* out_s, NodeAttributes* out_attributes) {
  return DirectoryAdmin::Call::GetAttr(zx::unowned_channel(this->channel_), out_s, out_attributes);
}

zx_status_t DirectoryAdmin::Call::GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse> DirectoryAdmin::SyncClient::GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  return DirectoryAdmin::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_attributes);
}

::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse> DirectoryAdmin::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_attributes = std::move(_response.attributes);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse> DirectoryAdmin::SyncClient::GetAttr(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::GetAttr(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse> DirectoryAdmin::Call::GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  return DirectoryAdmin::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes), out_s);
}

zx_status_t DirectoryAdmin::Call::SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse> DirectoryAdmin::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse> DirectoryAdmin::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetAttrResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse> DirectoryAdmin::SyncClient::SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::SetAttr(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse> DirectoryAdmin::Call::SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::SetAttrResponse>());
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::SetAttrResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::SetAttrResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<DirectoryAdmin::IoctlResponse> DirectoryAdmin::SyncClient::Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  return DirectoryAdmin::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(opcode), std::move(max_out), std::move(handles), std::move(in), std::move(_response_buffer), out_s, out_handles, out_out);
}

::fidl::DecodeResult<DirectoryAdmin::IoctlResponse> DirectoryAdmin::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out) {
  if (_request_buffer.capacity() < IoctlRequest::PrimarySize) {
    return ::fidl::DecodeResult<IoctlResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  IoctlRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Ioctl_Ordinal;
  _request.opcode = std::move(opcode);
  _request.max_out = std::move(max_out);
  _request.handles = std::move(handles);
  _request.in = std::move(in);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<IoctlRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<IoctlResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_handles = std::move(_response.handles);
  *out_out = std::move(_response.out);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::IoctlResponse> DirectoryAdmin::SyncClient::Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Ioctl(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::IoctlResponse> DirectoryAdmin::Call::Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Ioctl_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::IoctlResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::IoctlResponse>());
  }
  auto _call_result = ::fidl::Call<IoctlRequest, IoctlResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::IoctlResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::IoctlResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return DirectoryAdmin::Call::Open(zx::unowned_channel(this->channel_), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

zx_status_t DirectoryAdmin::Call::Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OpenRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Open_Ordinal;
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return DirectoryAdmin::Call::Open(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

zx_status_t DirectoryAdmin::Call::Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OpenRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Open_Ordinal;
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::Open(::fidl::DecodedMessage<OpenRequest> params) {
  return DirectoryAdmin::Call::Open(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t DirectoryAdmin::Call::Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Open_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Unlink(::fidl::StringView path, int32_t* out_s) {
  return DirectoryAdmin::Call::Unlink(zx::unowned_channel(this->channel_), std::move(path), out_s);
}

zx_status_t DirectoryAdmin::Call::Unlink(zx::unowned_channel _client_end, ::fidl::StringView path, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  UnlinkRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse> DirectoryAdmin::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Unlink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse> DirectoryAdmin::Call::Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    return ::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  UnlinkRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnlinkResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse> DirectoryAdmin::SyncClient::Unlink(::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Unlink(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse> DirectoryAdmin::Call::Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnlinkResponse>());
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnlinkResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnlinkResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse> DirectoryAdmin::SyncClient::ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents) {
  return DirectoryAdmin::Call::ReadDirents(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer), out_s, out_dirents);
}

::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse> DirectoryAdmin::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents) {
  if (_request_buffer.capacity() < ReadDirentsRequest::PrimarySize) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_ReadDirents_Ordinal;
  _request.max_bytes = std::move(max_bytes);
  _request_buffer.set_actual(sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ReadDirentsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_dirents = std::move(_response.dirents);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse> DirectoryAdmin::SyncClient::ReadDirents(::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::ReadDirents(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse> DirectoryAdmin::Call::ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_ReadDirents_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::ReadDirentsResponse>());
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::ReadDirentsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::ReadDirentsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Rewind(int32_t* out_s) {
  return DirectoryAdmin::Call::Rewind(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t DirectoryAdmin::Call::Rewind(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<RewindRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::RewindResponse> DirectoryAdmin::SyncClient::Rewind(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Rewind(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::RewindResponse> DirectoryAdmin::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<RewindRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  _request_buffer.set_actual(sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RewindResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RewindResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::RewindResponse> DirectoryAdmin::SyncClient::Rewind(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Rewind(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::RewindResponse> DirectoryAdmin::Call::Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(RewindRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<RewindRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RewindResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::RewindResponse>());
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RewindResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::RewindResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::GetToken(int32_t* out_s, ::zx::handle* out_token) {
  return DirectoryAdmin::Call::GetToken(zx::unowned_channel(this->channel_), out_s, out_token);
}

zx_status_t DirectoryAdmin::Call::GetToken(zx::unowned_channel _client_end, int32_t* out_s, ::zx::handle* out_token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetTokenRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_token = std::move(_response.token);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse> DirectoryAdmin::SyncClient::GetToken(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token) {
  return DirectoryAdmin::Call::GetToken(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_token);
}

::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse> DirectoryAdmin::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetTokenRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTokenResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTokenResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_token = std::move(_response.token);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse> DirectoryAdmin::SyncClient::GetToken(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::GetToken(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse> DirectoryAdmin::Call::GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetTokenResponse>());
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetTokenResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetTokenResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  return DirectoryAdmin::Call::Rename(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst), out_s);
}

zx_status_t DirectoryAdmin::Call::Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  RenameRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::RenameResponse> DirectoryAdmin::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Rename(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::RenameResponse> DirectoryAdmin::Call::Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    return ::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  RenameRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RenameResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::RenameResponse> DirectoryAdmin::SyncClient::Rename(::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Rename(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::RenameResponse> DirectoryAdmin::Call::Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RenameResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::RenameResponse>());
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::RenameResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::RenameResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  return DirectoryAdmin::Call::Link(zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst), out_s);
}

zx_status_t DirectoryAdmin::Call::Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  LinkRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::LinkResponse> DirectoryAdmin::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Link(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::LinkResponse> DirectoryAdmin::Call::Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    return ::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  LinkRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<LinkResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::LinkResponse> DirectoryAdmin::SyncClient::Link(::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Link(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::LinkResponse> DirectoryAdmin::Call::Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::LinkResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::LinkResponse>());
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::LinkResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::LinkResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s) {
  return DirectoryAdmin::Call::Watch(zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher), out_s);
}

zx_status_t DirectoryAdmin::Call::Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<WatchRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::WatchResponse> DirectoryAdmin::SyncClient::Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Watch(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::WatchResponse> DirectoryAdmin::Call::Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    return ::fidl::DecodeResult<WatchResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<WatchRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  _request_buffer.set_actual(sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WatchResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WatchResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::WatchResponse> DirectoryAdmin::SyncClient::Watch(::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Watch(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::WatchResponse> DirectoryAdmin::Call::Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::WatchResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::WatchResponse>());
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::WatchResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::WatchResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Mount(::zx::channel remote, int32_t* out_s) {
  return DirectoryAdmin::Call::Mount(zx::unowned_channel(this->channel_), std::move(remote), out_s);
}

zx_status_t DirectoryAdmin::Call::Mount(zx::unowned_channel _client_end, ::zx::channel remote, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MountRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  _request.remote = std::move(remote);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountRequest));
  ::fidl::DecodedMessage<MountRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MountResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MountRequest, MountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::MountResponse> DirectoryAdmin::SyncClient::Mount(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Mount(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(remote), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::MountResponse> DirectoryAdmin::Call::Mount(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < MountRequest::PrimarySize) {
    return ::fidl::DecodeResult<MountResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MountRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  _request.remote = std::move(remote);
  _request_buffer.set_actual(sizeof(MountRequest));
  ::fidl::DecodedMessage<MountRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MountResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MountRequest, MountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MountResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::MountResponse> DirectoryAdmin::SyncClient::Mount(::fidl::DecodedMessage<MountRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Mount(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::MountResponse> DirectoryAdmin::Call::Mount(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::MountResponse>());
  }
  auto _call_result = ::fidl::Call<MountRequest, MountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::MountResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::MountAndCreate(::zx::channel remote, ::fidl::StringView name, uint32_t flags, int32_t* out_s) {
  return DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel(this->channel_), std::move(remote), std::move(name), std::move(flags), out_s);
}

zx_status_t DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel _client_end, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountAndCreateRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  MountAndCreateRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  _request.remote = std::move(remote);
  _request.name = std::move(name);
  _request.flags = std::move(flags);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<MountAndCreateRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MountAndCreateResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MountAndCreateRequest, MountAndCreateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse> DirectoryAdmin::SyncClient::MountAndCreate(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(remote), std::move(name), std::move(flags), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse> DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  if (_request_buffer.capacity() < MountAndCreateRequest::PrimarySize) {
    return ::fidl::DecodeResult<MountAndCreateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  MountAndCreateRequest _request = {};
  _request._hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  _request.remote = std::move(remote);
  _request.name = std::move(name);
  _request.flags = std::move(flags);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MountAndCreateResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<MountAndCreateRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MountAndCreateResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MountAndCreateRequest, MountAndCreateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MountAndCreateResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse> DirectoryAdmin::SyncClient::MountAndCreate(::fidl::DecodedMessage<MountAndCreateRequest> params, ::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse> DirectoryAdmin::Call::MountAndCreate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountAndCreateRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::MountAndCreateResponse>());
  }
  auto _call_result = ::fidl::Call<MountAndCreateRequest, MountAndCreateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::MountAndCreateResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::MountAndCreateResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::Unmount(int32_t* out_s) {
  return DirectoryAdmin::Call::Unmount(zx::unowned_channel(this->channel_), out_s);
}

zx_status_t DirectoryAdmin::Call::Unmount(zx::unowned_channel _client_end, int32_t* out_s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<UnmountRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountRequest));
  ::fidl::DecodedMessage<UnmountRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<UnmountResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<UnmountRequest, UnmountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::UnmountResponse> DirectoryAdmin::SyncClient::Unmount(::fidl::BytePart _response_buffer, int32_t* out_s) {
  return DirectoryAdmin::Call::Unmount(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s);
}

::fidl::DecodeResult<DirectoryAdmin::UnmountResponse> DirectoryAdmin::Call::Unmount(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<UnmountRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  _request_buffer.set_actual(sizeof(UnmountRequest));
  ::fidl::DecodedMessage<UnmountRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnmountResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<UnmountRequest, UnmountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnmountResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::UnmountResponse> DirectoryAdmin::SyncClient::Unmount(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::Unmount(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnmountResponse> DirectoryAdmin::Call::Unmount(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(UnmountRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<UnmountRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnmountResponse>());
  }
  auto _call_result = ::fidl::Call<UnmountRequest, UnmountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnmountResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t DirectoryAdmin::SyncClient::UnmountNode(int32_t* out_s, ::zx::channel* out_remote) {
  return DirectoryAdmin::Call::UnmountNode(zx::unowned_channel(this->channel_), out_s, out_remote);
}

zx_status_t DirectoryAdmin::Call::UnmountNode(zx::unowned_channel _client_end, int32_t* out_s, ::zx::channel* out_remote) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountNodeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<UnmountNodeRequest*>(_write_bytes);
  _request._hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountNodeRequest));
  ::fidl::DecodedMessage<UnmountNodeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<UnmountNodeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<UnmountNodeRequest, UnmountNodeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_remote = std::move(_response.remote);
  return ZX_OK;
}

::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse> DirectoryAdmin::SyncClient::UnmountNode(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::channel* out_remote) {
  return DirectoryAdmin::Call::UnmountNode(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_remote);
}

::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse> DirectoryAdmin::Call::UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::channel* out_remote) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountNodeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<UnmountNodeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  _request_buffer.set_actual(sizeof(UnmountNodeRequest));
  ::fidl::DecodedMessage<UnmountNodeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnmountNodeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<UnmountNodeRequest, UnmountNodeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnmountNodeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_remote = std::move(_response.remote);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse> DirectoryAdmin::SyncClient::UnmountNode(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::UnmountNode(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse> DirectoryAdmin::Call::UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnmountNodeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(UnmountNodeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<UnmountNodeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnmountNodeResponse>());
  }
  auto _call_result = ::fidl::Call<UnmountNodeRequest, UnmountNodeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::UnmountNodeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::UnmountNodeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse> DirectoryAdmin::SyncClient::QueryFilesystem(::fidl::BytePart _response_buffer, int32_t* out_s, FilesystemInfo** out_info) {
  return DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_info);
}

::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse> DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, FilesystemInfo** out_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(QueryFilesystemRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<QueryFilesystemRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_QueryFilesystem_Ordinal;
  _request_buffer.set_actual(sizeof(QueryFilesystemRequest));
  ::fidl::DecodedMessage<QueryFilesystemRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<QueryFilesystemResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<QueryFilesystemRequest, QueryFilesystemResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<QueryFilesystemResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_info = std::move(_response.info);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse> DirectoryAdmin::SyncClient::QueryFilesystem(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse> DirectoryAdmin::Call::QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(QueryFilesystemRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(QueryFilesystemRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<QueryFilesystemRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_QueryFilesystem_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::QueryFilesystemResponse>());
  }
  auto _call_result = ::fidl::Call<QueryFilesystemRequest, QueryFilesystemResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::QueryFilesystemResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::QueryFilesystemResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse> DirectoryAdmin::SyncClient::GetDevicePath(::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::StringView* out_path) {
  return DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_s, out_path);
}

::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse> DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::StringView* out_path) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDevicePathRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetDevicePathRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDirectoryAdmin_GetDevicePath_Ordinal;
  _request_buffer.set_actual(sizeof(GetDevicePathRequest));
  ::fidl::DecodedMessage<GetDevicePathRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDevicePathResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetDevicePathRequest, GetDevicePathResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDevicePathResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_path = std::move(_response.path);
  return _decode_result;
}

::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse> DirectoryAdmin::SyncClient::GetDevicePath(::fidl::BytePart response_buffer) {
  return DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse> DirectoryAdmin::Call::GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDevicePathRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetDevicePathRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetDevicePathRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetDevicePath_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetDevicePathResponse>());
  }
  auto _call_result = ::fidl::Call<GetDevicePathRequest, GetDevicePathResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryAdmin::GetDevicePathResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DirectoryAdmin::GetDevicePathResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t DirectoryAdmin::SyncClient::HandleEvents(DirectoryAdmin::EventHandlers handlers) {
  return DirectoryAdmin::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t DirectoryAdmin::Call::HandleEvents(zx::unowned_channel client_end,
                                            DirectoryAdmin::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kDirectoryAdmin_OnOpen_Ordinal: {
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool DirectoryAdmin::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDirectoryAdmin_Clone_Ordinal: {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
        Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Describe_Ordinal: {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
        Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
        Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_SetAttr_Ordinal: {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
        Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Ioctl_Ordinal: {
      auto result = ::fidl::DecodeAs<IoctlRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Ioctl(std::move(message->opcode), std::move(message->max_out), std::move(message->handles), std::move(message->in),
        Interface::IoctlCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Open_Ordinal: {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->flags), std::move(message->mode), std::move(message->path), std::move(message->object),
        Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Unlink_Ordinal: {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
        Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_ReadDirents_Ordinal: {
      auto result = ::fidl::DecodeAs<ReadDirentsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadDirents(std::move(message->max_bytes),
        Interface::ReadDirentsCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Rewind_Ordinal: {
      auto result = ::fidl::DecodeAs<RewindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Rewind(
        Interface::RewindCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetToken_Ordinal: {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
        Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Rename_Ordinal: {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
        Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Link_Ordinal: {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
        Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Watch_Ordinal: {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
        Interface::WatchCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Mount_Ordinal: {
      auto result = ::fidl::DecodeAs<MountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Mount(std::move(message->remote),
        Interface::MountCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_MountAndCreate_Ordinal: {
      auto result = ::fidl::DecodeAs<MountAndCreateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MountAndCreate(std::move(message->remote), std::move(message->name), std::move(message->flags),
        Interface::MountAndCreateCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_Unmount_Ordinal: {
      auto result = ::fidl::DecodeAs<UnmountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Unmount(
        Interface::UnmountCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_UnmountNode_Ordinal: {
      auto result = ::fidl::DecodeAs<UnmountNodeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->UnmountNode(
        Interface::UnmountNodeCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_QueryFilesystem_Ordinal: {
      auto result = ::fidl::DecodeAs<QueryFilesystemRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->QueryFilesystem(
        Interface::QueryFilesystemCompleter::Sync(txn));
      return true;
    }
    case kDirectoryAdmin_GetDevicePath_Ordinal: {
      auto result = ::fidl::DecodeAs<GetDevicePathRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDevicePath(
        Interface::GetDevicePathCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryAdmin::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DirectoryAdmin::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Close_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DescribeResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DescribeResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(DescribeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DescribeResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Describe_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kDirectoryAdmin_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kDirectoryAdmin_OnOpen_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t DirectoryAdmin::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_OnOpen_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void DirectoryAdmin::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Sync_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(int32_t s, NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_SetAttr_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::IoctlCompleterBase::Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IoctlResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  IoctlResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::IoctlCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out) {
  if (_buffer.capacity() < IoctlResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  IoctlResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_Ioctl_Ordinal;
  _response.s = std::move(s);
  _response.handles = std::move(handles);
  _response.out = std::move(out);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::IoctlCompleterBase::Reply(::fidl::DecodedMessage<IoctlResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Ioctl_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Unlink_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadDirentsResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_ReadDirents_Ordinal;
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  if (_buffer.capacity() < ReadDirentsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadDirentsResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_ReadDirents_Ordinal;
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::ReadDirentsCompleterBase::Reply(::fidl::DecodedMessage<ReadDirentsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_ReadDirents_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::RewindCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RewindResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::RewindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RewindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RewindResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::RewindCompleterBase::Reply(::fidl::DecodedMessage<RewindResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Rewind_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(int32_t s, ::zx::handle token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  _response.s = std::move(s);
  _response.token = std::move(token);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  _response.s = std::move(s);
  _response.token = std::move(token);
  _buffer.set_actual(sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetToken_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::RenameCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RenameResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RenameResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Rename_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::LinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LinkResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LinkResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Link_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::WatchCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WatchResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::WatchCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < WatchResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WatchResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::WatchCompleterBase::Reply(::fidl::DecodedMessage<WatchResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Watch_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::MountCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MountResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::MountCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < MountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MountResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(MountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::MountCompleterBase::Reply(::fidl::DecodedMessage<MountResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Mount_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MountAndCreateResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MountAndCreateResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MountAndCreateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountAndCreateResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < MountAndCreateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MountAndCreateResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(MountAndCreateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MountAndCreateResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::MountAndCreateCompleterBase::Reply(::fidl::DecodedMessage<MountAndCreateResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_MountAndCreate_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnmountResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnmountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnmountResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnmountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnmountCompleterBase::Reply(::fidl::DecodedMessage<UnmountResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_Unmount_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(int32_t s, ::zx::channel remote) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnmountNodeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnmountNodeResponse*>(_write_bytes);
  _response._hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  _response.s = std::move(s);
  _response.remote = std::move(remote);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnmountNodeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountNodeResponse>(std::move(_response_bytes)));
}

void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::channel remote) {
  if (_buffer.capacity() < UnmountNodeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnmountNodeResponse*>(_buffer.data());
  _response._hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  _response.s = std::move(s);
  _response.remote = std::move(remote);
  _buffer.set_actual(sizeof(UnmountNodeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnmountNodeResponse>(std::move(_buffer)));
}

void DirectoryAdmin::Interface::UnmountNodeCompleterBase::Reply(::fidl::DecodedMessage<UnmountNodeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_UnmountNode_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(int32_t s, FilesystemInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<QueryFilesystemResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  QueryFilesystemResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_QueryFilesystem_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, FilesystemInfo* info) {
  if (_buffer.capacity() < QueryFilesystemResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  QueryFilesystemResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_QueryFilesystem_Ordinal;
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::QueryFilesystemCompleterBase::Reply(::fidl::DecodedMessage<QueryFilesystemResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_QueryFilesystem_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(int32_t s, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDevicePathResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetDevicePathResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_GetDevicePath_Ordinal;
  _response.s = std::move(s);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::StringView path) {
  if (_buffer.capacity() < GetDevicePathResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDevicePathResponse _response = {};
  _response._hdr.ordinal = kDirectoryAdmin_GetDevicePath_Ordinal;
  _response.s = std::move(s);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryAdmin::Interface::GetDevicePathCompleterBase::Reply(::fidl::DecodedMessage<GetDevicePathResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDirectoryAdmin_GetDevicePath_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace io
}  // namespace fuchsia
}  // namespace llcpp

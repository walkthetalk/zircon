// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/device/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace device {

namespace {

[[maybe_unused]]
constexpr uint64_t kController_Bind_Ordinal = 816958813lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerBindRequestTable;
extern "C" const fidl_type_t fuchsia_device_ControllerBindResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Unbind_Ordinal = 1601034312lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerUnbindResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetDriverName_Ordinal = 1989761741lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerGetDriverNameResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetDeviceName_Ordinal = 930755808lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerGetDeviceNameResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetTopologicalPath_Ordinal = 1125106390lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerGetTopologicalPathResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetEventHandle_Ordinal = 1942670134lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerGetEventHandleResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetDriverLogFlags_Ordinal = 1549496467lu << 32;
[[maybe_unused]]
constexpr uint64_t kController_SetDriverLogFlags_Ordinal = 2102817579lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerSetDriverLogFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_DebugSuspend_Ordinal = 1710371364lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerDebugSuspendResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_DebugResume_Ordinal = 1609443780lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerDebugResumeResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_RunCompatibilityTests_Ordinal = 1212996015lu << 32;
extern "C" const fidl_type_t fuchsia_device_ControllerRunCompatibilityTestsResponseTable;

}  // namespace

zx_status_t Controller::SyncClient::Bind(::fidl::StringView driver, int32_t* out_status) {
  return Controller::Call::Bind(zx::unowned_channel(this->channel_), std::move(driver), out_status);
}

zx_status_t Controller::Call::Bind(zx::unowned_channel _client_end, ::fidl::StringView driver, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  BindRequest _request = {};
  _request._hdr.ordinal = kController_Bind_Ordinal;
  _request.driver = std::move(driver);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<BindRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<BindResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<BindRequest, BindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::BindResponse> Controller::SyncClient::Bind(::fidl::BytePart _request_buffer, ::fidl::StringView driver, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Controller::Call::Bind(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(driver), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::BindResponse> Controller::Call::Bind(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView driver, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  if (_request_buffer.capacity() < BindRequest::PrimarySize) {
    return ::fidl::DecodeResult<BindResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  BindRequest _request = {};
  _request._hdr.ordinal = kController_Bind_Ordinal;
  _request.driver = std::move(driver);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BindResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<BindRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BindResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<BindRequest, BindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BindResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::BindResponse> Controller::SyncClient::Bind(::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer) {
  return Controller::Call::Bind(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::BindResponse> Controller::Call::Bind(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_Bind_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::BindResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::BindResponse>());
  }
  auto _call_result = ::fidl::Call<BindRequest, BindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::BindResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::BindResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::Unbind(int32_t* out_status) {
  return Controller::Call::Unbind(zx::unowned_channel(this->channel_), out_status);
}

zx_status_t Controller::Call::Unbind(zx::unowned_channel _client_end, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<UnbindRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_Unbind_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnbindRequest));
  ::fidl::DecodedMessage<UnbindRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<UnbindResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<UnbindRequest, UnbindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::UnbindResponse> Controller::SyncClient::Unbind(::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Controller::Call::Unbind(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::UnbindResponse> Controller::Call::Unbind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnbindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<UnbindRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_Unbind_Ordinal;
  _request_buffer.set_actual(sizeof(UnbindRequest));
  ::fidl::DecodedMessage<UnbindRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnbindResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<UnbindRequest, UnbindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<UnbindResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::UnbindResponse> Controller::SyncClient::Unbind(::fidl::BytePart response_buffer) {
  return Controller::Call::Unbind(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::UnbindResponse> Controller::Call::Unbind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(UnbindRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(UnbindRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<UnbindRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_Unbind_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::UnbindResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::UnbindResponse>());
  }
  auto _call_result = ::fidl::Call<UnbindRequest, UnbindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::UnbindResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::UnbindResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Controller::GetDriverNameResponse> Controller::SyncClient::GetDriverName(::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_name) {
  return Controller::Call::GetDriverName(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_name);
}

::fidl::DecodeResult<Controller::GetDriverNameResponse> Controller::Call::GetDriverName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_name) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDriverNameRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetDriverNameRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_GetDriverName_Ordinal;
  _request_buffer.set_actual(sizeof(GetDriverNameRequest));
  ::fidl::DecodedMessage<GetDriverNameRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDriverNameResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetDriverNameRequest, GetDriverNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDriverNameResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_name = std::move(_response.name);
  return _decode_result;
}

::fidl::DecodeResult<Controller::GetDriverNameResponse> Controller::SyncClient::GetDriverName(::fidl::BytePart response_buffer) {
  return Controller::Call::GetDriverName(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::GetDriverNameResponse> Controller::Call::GetDriverName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDriverNameRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetDriverNameRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetDriverNameRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDriverName_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDriverNameResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::GetDriverNameResponse>());
  }
  auto _call_result = ::fidl::Call<GetDriverNameRequest, GetDriverNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDriverNameResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::GetDriverNameResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Controller::GetDeviceNameResponse> Controller::SyncClient::GetDeviceName(::fidl::BytePart _response_buffer, ::fidl::StringView* out_name) {
  return Controller::Call::GetDeviceName(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_name);
}

::fidl::DecodeResult<Controller::GetDeviceNameResponse> Controller::Call::GetDeviceName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, ::fidl::StringView* out_name) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDeviceNameRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetDeviceNameRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_GetDeviceName_Ordinal;
  _request_buffer.set_actual(sizeof(GetDeviceNameRequest));
  ::fidl::DecodedMessage<GetDeviceNameRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDeviceNameResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetDeviceNameRequest, GetDeviceNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDeviceNameResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_name = std::move(_response.name);
  return _decode_result;
}

::fidl::DecodeResult<Controller::GetDeviceNameResponse> Controller::SyncClient::GetDeviceName(::fidl::BytePart response_buffer) {
  return Controller::Call::GetDeviceName(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::GetDeviceNameResponse> Controller::Call::GetDeviceName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDeviceNameRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetDeviceNameRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetDeviceNameRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDeviceName_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDeviceNameResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::GetDeviceNameResponse>());
  }
  auto _call_result = ::fidl::Call<GetDeviceNameRequest, GetDeviceNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDeviceNameResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::GetDeviceNameResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


::fidl::DecodeResult<Controller::GetTopologicalPathResponse> Controller::SyncClient::GetTopologicalPath(::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_path) {
  return Controller::Call::GetTopologicalPath(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_path);
}

::fidl::DecodeResult<Controller::GetTopologicalPathResponse> Controller::Call::GetTopologicalPath(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_path) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTopologicalPathRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetTopologicalPathRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_GetTopologicalPath_Ordinal;
  _request_buffer.set_actual(sizeof(GetTopologicalPathRequest));
  ::fidl::DecodedMessage<GetTopologicalPathRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTopologicalPathResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetTopologicalPathRequest, GetTopologicalPathResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetTopologicalPathResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_path = std::move(_response.path);
  return _decode_result;
}

::fidl::DecodeResult<Controller::GetTopologicalPathResponse> Controller::SyncClient::GetTopologicalPath(::fidl::BytePart response_buffer) {
  return Controller::Call::GetTopologicalPath(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::GetTopologicalPathResponse> Controller::Call::GetTopologicalPath(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTopologicalPathRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetTopologicalPathRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetTopologicalPathRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetTopologicalPath_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetTopologicalPathResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::GetTopologicalPathResponse>());
  }
  auto _call_result = ::fidl::Call<GetTopologicalPathRequest, GetTopologicalPathResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetTopologicalPathResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::GetTopologicalPathResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::GetEventHandle(int32_t* out_status, ::zx::event* out_event) {
  return Controller::Call::GetEventHandle(zx::unowned_channel(this->channel_), out_status, out_event);
}

zx_status_t Controller::Call::GetEventHandle(zx::unowned_channel _client_end, int32_t* out_status, ::zx::event* out_event) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetEventHandleRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetEventHandleRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_GetEventHandle_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetEventHandleRequest));
  ::fidl::DecodedMessage<GetEventHandleRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetEventHandleResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetEventHandleRequest, GetEventHandleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_event = std::move(_response.event);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::GetEventHandleResponse> Controller::SyncClient::GetEventHandle(::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::event* out_event) {
  return Controller::Call::GetEventHandle(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_event);
}

::fidl::DecodeResult<Controller::GetEventHandleResponse> Controller::Call::GetEventHandle(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::event* out_event) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetEventHandleRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetEventHandleRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_GetEventHandle_Ordinal;
  _request_buffer.set_actual(sizeof(GetEventHandleRequest));
  ::fidl::DecodedMessage<GetEventHandleRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetEventHandleResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetEventHandleRequest, GetEventHandleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetEventHandleResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_event = std::move(_response.event);
  return _decode_result;
}

::fidl::DecodeResult<Controller::GetEventHandleResponse> Controller::SyncClient::GetEventHandle(::fidl::BytePart response_buffer) {
  return Controller::Call::GetEventHandle(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::GetEventHandleResponse> Controller::Call::GetEventHandle(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetEventHandleRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetEventHandleRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetEventHandleRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetEventHandle_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetEventHandleResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::GetEventHandleResponse>());
  }
  auto _call_result = ::fidl::Call<GetEventHandleRequest, GetEventHandleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetEventHandleResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::GetEventHandleResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::GetDriverLogFlags(int32_t* out_status, uint32_t* out_flags) {
  return Controller::Call::GetDriverLogFlags(zx::unowned_channel(this->channel_), out_status, out_flags);
}

zx_status_t Controller::Call::GetDriverLogFlags(zx::unowned_channel _client_end, int32_t* out_status, uint32_t* out_flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDriverLogFlagsRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetDriverLogFlagsRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDriverLogFlagsRequest));
  ::fidl::DecodedMessage<GetDriverLogFlagsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetDriverLogFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetDriverLogFlagsRequest, GetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_flags = std::move(_response.flags);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse> Controller::SyncClient::GetDriverLogFlags(::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_flags) {
  return Controller::Call::GetDriverLogFlags(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_flags);
}

::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse> Controller::Call::GetDriverLogFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_flags) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDriverLogFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetDriverLogFlagsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  _request_buffer.set_actual(sizeof(GetDriverLogFlagsRequest));
  ::fidl::DecodedMessage<GetDriverLogFlagsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDriverLogFlagsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetDriverLogFlagsRequest, GetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetDriverLogFlagsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_flags = std::move(_response.flags);
  return _decode_result;
}

::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse> Controller::SyncClient::GetDriverLogFlags(::fidl::BytePart response_buffer) {
  return Controller::Call::GetDriverLogFlags(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse> Controller::Call::GetDriverLogFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDriverLogFlagsRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetDriverLogFlagsRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetDriverLogFlagsRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::GetDriverLogFlagsResponse>());
  }
  auto _call_result = ::fidl::Call<GetDriverLogFlagsRequest, GetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetDriverLogFlagsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::GetDriverLogFlagsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::SetDriverLogFlags(uint32_t clear_flags, uint32_t set_flags, int32_t* out_status) {
  return Controller::Call::SetDriverLogFlags(zx::unowned_channel(this->channel_), std::move(clear_flags), std::move(set_flags), out_status);
}

zx_status_t Controller::Call::SetDriverLogFlags(zx::unowned_channel _client_end, uint32_t clear_flags, uint32_t set_flags, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDriverLogFlagsRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetDriverLogFlagsRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  _request.clear_flags = std::move(clear_flags);
  _request.set_flags = std::move(set_flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDriverLogFlagsRequest));
  ::fidl::DecodedMessage<SetDriverLogFlagsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetDriverLogFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetDriverLogFlagsRequest, SetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse> Controller::SyncClient::SetDriverLogFlags(::fidl::BytePart _request_buffer, uint32_t clear_flags, uint32_t set_flags, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Controller::Call::SetDriverLogFlags(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(clear_flags), std::move(set_flags), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse> Controller::Call::SetDriverLogFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t clear_flags, uint32_t set_flags, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  if (_request_buffer.capacity() < SetDriverLogFlagsRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetDriverLogFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetDriverLogFlagsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  _request.clear_flags = std::move(clear_flags);
  _request.set_flags = std::move(set_flags);
  _request_buffer.set_actual(sizeof(SetDriverLogFlagsRequest));
  ::fidl::DecodedMessage<SetDriverLogFlagsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetDriverLogFlagsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetDriverLogFlagsRequest, SetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetDriverLogFlagsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse> Controller::SyncClient::SetDriverLogFlags(::fidl::DecodedMessage<SetDriverLogFlagsRequest> params, ::fidl::BytePart response_buffer) {
  return Controller::Call::SetDriverLogFlags(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse> Controller::Call::SetDriverLogFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDriverLogFlagsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::SetDriverLogFlagsResponse>());
  }
  auto _call_result = ::fidl::Call<SetDriverLogFlagsRequest, SetDriverLogFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetDriverLogFlagsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::SetDriverLogFlagsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::DebugSuspend(int32_t* out_status) {
  return Controller::Call::DebugSuspend(zx::unowned_channel(this->channel_), out_status);
}

zx_status_t Controller::Call::DebugSuspend(zx::unowned_channel _client_end, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DebugSuspendRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DebugSuspendRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_DebugSuspend_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DebugSuspendRequest));
  ::fidl::DecodedMessage<DebugSuspendRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DebugSuspendResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DebugSuspendRequest, DebugSuspendResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::DebugSuspendResponse> Controller::SyncClient::DebugSuspend(::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Controller::Call::DebugSuspend(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::DebugSuspendResponse> Controller::Call::DebugSuspend(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DebugSuspendRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DebugSuspendRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_DebugSuspend_Ordinal;
  _request_buffer.set_actual(sizeof(DebugSuspendRequest));
  ::fidl::DecodedMessage<DebugSuspendRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DebugSuspendResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DebugSuspendRequest, DebugSuspendResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DebugSuspendResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::DebugSuspendResponse> Controller::SyncClient::DebugSuspend(::fidl::BytePart response_buffer) {
  return Controller::Call::DebugSuspend(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::DebugSuspendResponse> Controller::Call::DebugSuspend(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DebugSuspendRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DebugSuspendRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DebugSuspendRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DebugSuspend_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::DebugSuspendResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::DebugSuspendResponse>());
  }
  auto _call_result = ::fidl::Call<DebugSuspendRequest, DebugSuspendResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::DebugSuspendResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::DebugSuspendResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::DebugResume(int32_t* out_status) {
  return Controller::Call::DebugResume(zx::unowned_channel(this->channel_), out_status);
}

zx_status_t Controller::Call::DebugResume(zx::unowned_channel _client_end, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DebugResumeRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DebugResumeRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_DebugResume_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DebugResumeRequest));
  ::fidl::DecodedMessage<DebugResumeRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DebugResumeResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DebugResumeRequest, DebugResumeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::DebugResumeResponse> Controller::SyncClient::DebugResume(::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Controller::Call::DebugResume(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::DebugResumeResponse> Controller::Call::DebugResume(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DebugResumeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<DebugResumeRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_DebugResume_Ordinal;
  _request_buffer.set_actual(sizeof(DebugResumeRequest));
  ::fidl::DecodedMessage<DebugResumeRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DebugResumeResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<DebugResumeRequest, DebugResumeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DebugResumeResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::DebugResumeResponse> Controller::SyncClient::DebugResume(::fidl::BytePart response_buffer) {
  return Controller::Call::DebugResume(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::DebugResumeResponse> Controller::Call::DebugResume(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DebugResumeRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(DebugResumeRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<DebugResumeRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DebugResume_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::DebugResumeResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::DebugResumeResponse>());
  }
  auto _call_result = ::fidl::Call<DebugResumeRequest, DebugResumeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::DebugResumeResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::DebugResumeResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Controller::SyncClient::RunCompatibilityTests(int64_t hook_wait_time, uint32_t* out_status) {
  return Controller::Call::RunCompatibilityTests(zx::unowned_channel(this->channel_), std::move(hook_wait_time), out_status);
}

zx_status_t Controller::Call::RunCompatibilityTests(zx::unowned_channel _client_end, int64_t hook_wait_time, uint32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RunCompatibilityTestsRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<RunCompatibilityTestsRequest*>(_write_bytes);
  _request._hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  _request.hook_wait_time = std::move(hook_wait_time);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RunCompatibilityTestsRequest));
  ::fidl::DecodedMessage<RunCompatibilityTestsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<RunCompatibilityTestsResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<RunCompatibilityTestsRequest, RunCompatibilityTestsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse> Controller::SyncClient::RunCompatibilityTests(::fidl::BytePart _request_buffer, int64_t hook_wait_time, ::fidl::BytePart _response_buffer, uint32_t* out_status) {
  return Controller::Call::RunCompatibilityTests(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(hook_wait_time), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse> Controller::Call::RunCompatibilityTests(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t hook_wait_time, ::fidl::BytePart _response_buffer, uint32_t* out_status) {
  if (_request_buffer.capacity() < RunCompatibilityTestsRequest::PrimarySize) {
    return ::fidl::DecodeResult<RunCompatibilityTestsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<RunCompatibilityTestsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  _request.hook_wait_time = std::move(hook_wait_time);
  _request_buffer.set_actual(sizeof(RunCompatibilityTestsRequest));
  ::fidl::DecodedMessage<RunCompatibilityTestsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RunCompatibilityTestsResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<RunCompatibilityTestsRequest, RunCompatibilityTestsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<RunCompatibilityTestsResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse> Controller::SyncClient::RunCompatibilityTests(::fidl::DecodedMessage<RunCompatibilityTestsRequest> params, ::fidl::BytePart response_buffer) {
  return Controller::Call::RunCompatibilityTests(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse> Controller::Call::RunCompatibilityTests(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RunCompatibilityTestsRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Controller::RunCompatibilityTestsResponse>());
  }
  auto _call_result = ::fidl::Call<RunCompatibilityTestsRequest, RunCompatibilityTestsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::RunCompatibilityTestsResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Controller::RunCompatibilityTestsResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kController_Bind_Ordinal: {
      auto result = ::fidl::DecodeAs<BindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Bind(std::move(message->driver),
        Interface::BindCompleter::Sync(txn));
      return true;
    }
    case kController_Unbind_Ordinal: {
      auto result = ::fidl::DecodeAs<UnbindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Unbind(
        Interface::UnbindCompleter::Sync(txn));
      return true;
    }
    case kController_GetDriverName_Ordinal: {
      auto result = ::fidl::DecodeAs<GetDriverNameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDriverName(
        Interface::GetDriverNameCompleter::Sync(txn));
      return true;
    }
    case kController_GetDeviceName_Ordinal: {
      auto result = ::fidl::DecodeAs<GetDeviceNameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDeviceName(
        Interface::GetDeviceNameCompleter::Sync(txn));
      return true;
    }
    case kController_GetTopologicalPath_Ordinal: {
      auto result = ::fidl::DecodeAs<GetTopologicalPathRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetTopologicalPath(
        Interface::GetTopologicalPathCompleter::Sync(txn));
      return true;
    }
    case kController_GetEventHandle_Ordinal: {
      auto result = ::fidl::DecodeAs<GetEventHandleRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetEventHandle(
        Interface::GetEventHandleCompleter::Sync(txn));
      return true;
    }
    case kController_GetDriverLogFlags_Ordinal: {
      auto result = ::fidl::DecodeAs<GetDriverLogFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDriverLogFlags(
        Interface::GetDriverLogFlagsCompleter::Sync(txn));
      return true;
    }
    case kController_SetDriverLogFlags_Ordinal: {
      auto result = ::fidl::DecodeAs<SetDriverLogFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDriverLogFlags(std::move(message->clear_flags), std::move(message->set_flags),
        Interface::SetDriverLogFlagsCompleter::Sync(txn));
      return true;
    }
    case kController_DebugSuspend_Ordinal: {
      auto result = ::fidl::DecodeAs<DebugSuspendRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->DebugSuspend(
        Interface::DebugSuspendCompleter::Sync(txn));
      return true;
    }
    case kController_DebugResume_Ordinal: {
      auto result = ::fidl::DecodeAs<DebugResumeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->DebugResume(
        Interface::DebugResumeCompleter::Sync(txn));
      return true;
    }
    case kController_RunCompatibilityTests_Ordinal: {
      auto result = ::fidl::DecodeAs<RunCompatibilityTestsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->RunCompatibilityTests(std::move(message->hook_wait_time),
        Interface::RunCompatibilityTestsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Controller::Interface::BindCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<BindResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_Bind_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(BindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<BindResponse>(std::move(_response_bytes)));
}

void Controller::Interface::BindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < BindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<BindResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_Bind_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(BindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<BindResponse>(std::move(_buffer)));
}

void Controller::Interface::BindCompleterBase::Reply(::fidl::DecodedMessage<BindResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_Bind_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::UnbindCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnbindResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_Unbind_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnbindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnbindResponse>(std::move(_response_bytes)));
}

void Controller::Interface::UnbindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < UnbindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnbindResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_Unbind_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(UnbindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnbindResponse>(std::move(_buffer)));
}

void Controller::Interface::UnbindCompleterBase::Reply(::fidl::DecodedMessage<UnbindResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_Unbind_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetDriverNameCompleterBase::Reply(int32_t status, ::fidl::StringView name) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDriverNameResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetDriverNameResponse _response = {};
  _response._hdr.ordinal = kController_GetDriverName_Ordinal;
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetDriverNameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::StringView name) {
  if (_buffer.capacity() < GetDriverNameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDriverNameResponse _response = {};
  _response._hdr.ordinal = kController_GetDriverName_Ordinal;
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetDriverNameCompleterBase::Reply(::fidl::DecodedMessage<GetDriverNameResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDriverName_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetDeviceNameCompleterBase::Reply(::fidl::StringView name) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDeviceNameResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetDeviceNameResponse _response = {};
  _response._hdr.ordinal = kController_GetDeviceName_Ordinal;
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetDeviceNameCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::StringView name) {
  if (_buffer.capacity() < GetDeviceNameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDeviceNameResponse _response = {};
  _response._hdr.ordinal = kController_GetDeviceName_Ordinal;
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetDeviceNameCompleterBase::Reply(::fidl::DecodedMessage<GetDeviceNameResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDeviceName_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetTopologicalPathCompleterBase::Reply(int32_t status, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTopologicalPathResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetTopologicalPathResponse _response = {};
  _response._hdr.ordinal = kController_GetTopologicalPath_Ordinal;
  _response.status = std::move(status);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetTopologicalPathCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::StringView path) {
  if (_buffer.capacity() < GetTopologicalPathResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTopologicalPathResponse _response = {};
  _response._hdr.ordinal = kController_GetTopologicalPath_Ordinal;
  _response.status = std::move(status);
  _response.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetTopologicalPathCompleterBase::Reply(::fidl::DecodedMessage<GetTopologicalPathResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetTopologicalPath_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetEventHandleCompleterBase::Reply(int32_t status, ::zx::event event) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetEventHandleResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetEventHandleResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_GetEventHandle_Ordinal;
  _response.status = std::move(status);
  _response.event = std::move(event);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetEventHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetEventHandleResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetEventHandleCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::zx::event event) {
  if (_buffer.capacity() < GetEventHandleResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetEventHandleResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_GetEventHandle_Ordinal;
  _response.status = std::move(status);
  _response.event = std::move(event);
  _buffer.set_actual(sizeof(GetEventHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetEventHandleResponse>(std::move(_buffer)));
}

void Controller::Interface::GetEventHandleCompleterBase::Reply(::fidl::DecodedMessage<GetEventHandleResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetEventHandle_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetDriverLogFlagsCompleterBase::Reply(int32_t status, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDriverLogFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetDriverLogFlagsResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  _response.status = std::move(status);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDriverLogFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetDriverLogFlagsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetDriverLogFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint32_t flags) {
  if (_buffer.capacity() < GetDriverLogFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetDriverLogFlagsResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  _response.status = std::move(status);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(GetDriverLogFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetDriverLogFlagsResponse>(std::move(_buffer)));
}

void Controller::Interface::GetDriverLogFlagsCompleterBase::Reply(::fidl::DecodedMessage<GetDriverLogFlagsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_GetDriverLogFlags_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::SetDriverLogFlagsCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDriverLogFlagsResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetDriverLogFlagsResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDriverLogFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetDriverLogFlagsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::SetDriverLogFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetDriverLogFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetDriverLogFlagsResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetDriverLogFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetDriverLogFlagsResponse>(std::move(_buffer)));
}

void Controller::Interface::SetDriverLogFlagsCompleterBase::Reply(::fidl::DecodedMessage<SetDriverLogFlagsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_SetDriverLogFlags_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::DebugSuspendCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DebugSuspendResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DebugSuspendResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_DebugSuspend_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DebugSuspendResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DebugSuspendResponse>(std::move(_response_bytes)));
}

void Controller::Interface::DebugSuspendCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < DebugSuspendResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DebugSuspendResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_DebugSuspend_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(DebugSuspendResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DebugSuspendResponse>(std::move(_buffer)));
}

void Controller::Interface::DebugSuspendCompleterBase::Reply(::fidl::DecodedMessage<DebugSuspendResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DebugSuspend_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::DebugResumeCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DebugResumeResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DebugResumeResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_DebugResume_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DebugResumeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DebugResumeResponse>(std::move(_response_bytes)));
}

void Controller::Interface::DebugResumeCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < DebugResumeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<DebugResumeResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_DebugResume_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(DebugResumeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DebugResumeResponse>(std::move(_buffer)));
}

void Controller::Interface::DebugResumeCompleterBase::Reply(::fidl::DecodedMessage<DebugResumeResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_DebugResume_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::RunCompatibilityTestsCompleterBase::Reply(uint32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RunCompatibilityTestsResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RunCompatibilityTestsResponse*>(_write_bytes);
  _response._hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RunCompatibilityTestsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RunCompatibilityTestsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::RunCompatibilityTestsCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t status) {
  if (_buffer.capacity() < RunCompatibilityTestsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RunCompatibilityTestsResponse*>(_buffer.data());
  _response._hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(RunCompatibilityTestsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RunCompatibilityTestsResponse>(std::move(_buffer)));
}

void Controller::Interface::RunCompatibilityTestsCompleterBase::Reply(::fidl::DecodedMessage<RunCompatibilityTestsResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kController_RunCompatibilityTests_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace sysmem {

struct VmoBuffer;
class BufferCollectionToken;
class Heap;
class DriverConnector;
class Allocator;
enum class PixelFormatType : uint32_t {
  INVALID = 0u,
  R8G8B8A8 = 1u,
  BGRA32 = 101u,
  I420 = 102u,
  M420 = 103u,
  NV12 = 104u,
  YUY2 = 105u,
  MJPEG = 106u,
  YV12 = 107u,
};


struct ImagePlane;
enum class HeapType : uint64_t {
  SYSTEM_RAM = 0u,
  AMLOGIC_SECURE = 1152921504606912512u,
  GOLDFISH_DEVICE_LOCAL = 1152921504606978048u,
};


struct BufferMemoryConstraints;
struct FormatModifier;
struct PixelFormat;
enum class ColorSpaceType : uint32_t {
  INVALID = 0u,
  SRGB = 1u,
  REC601_NTSC = 2u,
  REC601_NTSC_FULL_RANGE = 3u,
  REC601_PAL = 4u,
  REC601_PAL_FULL_RANGE = 5u,
  REC709 = 6u,
  REC2020 = 7u,
  REC2100 = 8u,
};


struct ColorSpace;
struct ImageSpec;
struct BufferSpec;
struct ImageFormat_2;
struct ImageFormatConstraints;
struct ImageFormat;
struct BufferFormat;
struct BufferCollectionInfo;
enum class CoherencyDomain : uint32_t {
  CPU = 0u,
  RAM = 1u,
  INACCESSIBLE = 2u,
};


struct BufferMemorySettings;
struct SingleBufferSettings;
struct SingleBufferInfo;
struct BufferCollectionInfo_2;
class BufferCollectionEvents;
struct BufferUsage;
struct BufferCollectionConstraints;
class BufferCollection;

constexpr uint32_t vulkanUsageTransientAttachment = 64u;

constexpr uint32_t vulkanUsageTransferSrc = 1u;

constexpr uint32_t vulkanUsageTransferDst = 2u;

constexpr uint32_t vulkanUsageStorage = 8u;

constexpr uint32_t vulkanUsageStencilAttachment = 32u;

constexpr uint32_t vulkanUsageSampled = 4u;

constexpr uint32_t vulkanUsageInputAttachment = 128u;

constexpr uint32_t vulkanUsageColorAttachment = 16u;

constexpr uint32_t videoUsageHwProtected = 4u;

constexpr uint32_t videoUsageHwEncoder = 2u;

constexpr uint32_t videoUsageHwDecoder = 1u;

constexpr uint32_t displayUsageLayer = 1u;

constexpr uint32_t displayUsageCursor = 2u;

constexpr uint32_t cpuUsageWriteOften = 8u;

constexpr uint32_t cpuUsageWrite = 4u;

constexpr uint32_t cpuUsageReadOften = 2u;

constexpr uint32_t cpuUsageRead = 1u;

extern "C" const fidl_type_t fuchsia_sysmem_VmoBufferTable;

struct VmoBuffer {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_VmoBufferTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The same VMO can be used by more than one CodecBuffer (only of the same
  // buffer_lifetime_ordinal), but each vmo_handle must be a separate handle.
  //
  // The vmo field can be 0 if this is a VmoBuffer in BufferCollectionInfo_2
  // that's at or beyond BufferCollectionInfo_2.buffer_count.
  ::zx::vmo vmo{};

  // Offset within the VMO of the first usable byte.  Must be < the VMO's size
  // in bytes, and leave sufficient room for BufferMemorySettings.size_bytes
  // before the end of the VMO.
  uint64_t vmo_usable_start{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;

// A BufferCollectionToken is not a BufferCollection, but rather a way to
// identify a potential shared BufferCollection prior to the BufferCollection
// being allocated.
//
// We use a channel for the BufferCollectionToken instead of a single eventpair
// (pair) because this way we can detect error conditions like a participant
// dying mid-create.
class BufferCollectionToken final {
 public:
  static constexpr char Name_[] = "fuchsia.sysmem.BufferCollectionToken";

  struct DuplicateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t rights_attenuation_mask;
    ::zx::channel token_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using SyncResponse = ::fidl::AnyZeroArgMessage;
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  using CloseRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    zx_status_t Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Duplicate(::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    // Messages are encoded and decoded in-place.
    zx_status_t Duplicate(::fidl::DecodedMessage<DuplicateRequest> params);

    // Ensure that previous Duplicate() messages have been received server side,
    // so that it's safe to send the client end of token_request to another
    // participant knowing the server will recognize the token when it's sent
    // into BindSharedCollection by the other participant.
    //
    // Other options include waiting for each Duplicate() to complete
    // individually, or calling Sync() on BufferCollection after this token has
    // been turned in via BindSharedCollection(), or noticing arrival of
    // BufferCollectionEvents::OnDuplicatedTokensKnownByServer().
    zx_status_t Sync();

    // Normally a participant will convert the token into a BufferCollection
    // view, but a particpant is also free to Close() the token (and then close
    // the channel immediately or shortly later in response to server closing
    // its end), which avoids causing LogicalBufferCollection failure.
    // Normally an unexpected token channel close will cause
    // LogicalBufferCollection failure.
    zx_status_t Close();

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    static zx_status_t Duplicate(zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Duplicate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request);

    // The initiator or a participant can send Duplicate() as part of creating
    // another participant-side handle to the same logical
    // BufferCollectionToken.
    //
    // This method is used to hand the logical token to all participants so all
    // participants can provide constraints to sysmem for the overall
    // BufferCollection to achieve the goal of allocating buffers compatible
    // with all participants.
    //
    // The Duplicate() message is intentionally available only on
    // BufferCollectionToken not BufferCollection.
    //
    // The token is separate from BufferCollection so that participants contact
    // sysmem directly, so that participants are only trusting their environment
    // for who sysmem is (fake token mitigation), not an initiator.  Only after
    // successful BindSharedCollection does a participant know that the token
    // was a real sysmem token.  In contrast, if we had Duplicate() directly on
    // BufferCollection, an initiator could attempt to serve the
    // BufferCollection channel itself, which would allow for some problematic
    // possibilities.
    //
    // All the BufferCollectionToken channels of a logical token must be turned
    // in via BindSharedCollection() for a BufferCollection to be successfully
    // created.  Else the BufferCollection channel will close.
    //
    // When a client calls BindSharedCollection() to turn in a
    // BufferCollectionToken, the server will process all Duplicate() messages
    // before closing down the BufferCollectionToken.  This allows the client
    // to Duplicate() and immediately turn in the BufferCollectionToken using
    // BindSharedCollection, then later transfer the client end of token_request
    // to another participant - the server will notice the existence of the
    // token_request before considering this BufferCollectionToken fully closed.
    //
    // `rights_attenuation_mask` rights bits that are zero in this mask will be
    // absent in the buffer VMO rights obtainable via the client end of
    // token_request.  This allows an initiator or intermediary participant
    // to attenuate the rights available to a participant.  This may not be the
    // only mechanism that attenuates rights on the VMO handles obtainable via
    // the client end of token_request.  This does not allow a participant
    // to gain rights that the participant doesn't already have.
    //
    // `token_request` is the server end of a BufferCollectionToken channel.
    // The client end of this channel acts as another handle to the same logical
    // BufferCollectionToken.  Typically the sender of Duplicate() will transfer
    // the client end corresponding to collection_request to a/another
    // participant running in a separate process, but it's also fine for the
    // additional logical participant to be in the same process.
    //
    // After sending one or more Duplicate() messages, and before sending the
    // created tokens to other participants (or to other Allocator2 channels),
    // the client should send a Sync() and wait for its response.  The Sync()
    // call can be made on the token, or on the BufferCollection obtained by
    // passing this token to BindSharedCollection().  Either will ensure that
    // the server knows about the tokens created via Duplicate() before the
    // other participant sends the token to the server via separate Allocator2
    // channel.  If a client is using FIDL C generated code and doesn't want to
    // block waiting for a response message, the other option is to notice
    // arrival of the BufferCollectionEvents::OnBufferCollectionCreated() event
    // after turning in this token for a BufferCollection.
    // Messages are encoded and decoded in-place.
    static zx_status_t Duplicate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DuplicateRequest> params);

    // Ensure that previous Duplicate() messages have been received server side,
    // so that it's safe to send the client end of token_request to another
    // participant knowing the server will recognize the token when it's sent
    // into BindSharedCollection by the other participant.
    //
    // Other options include waiting for each Duplicate() to complete
    // individually, or calling Sync() on BufferCollection after this token has
    // been turned in via BindSharedCollection(), or noticing arrival of
    // BufferCollectionEvents::OnDuplicatedTokensKnownByServer().
    static zx_status_t Sync(zx::unowned_channel _client_end);

    // Normally a participant will convert the token into a BufferCollection
    // view, but a particpant is also free to Close() the token (and then close
    // the channel immediately or shortly later in response to server closing
    // its end), which avoids causing LogicalBufferCollection failure.
    // Normally an unexpected token channel close will cause
    // LogicalBufferCollection failure.
    static zx_status_t Close(zx::unowned_channel _client_end);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollectionToken;
    using _Base = ::fidl::CompleterBase;

    using DuplicateCompleter = ::fidl::Completer<>;

    virtual void Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request, DuplicateCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_HeapAllocateVmoResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceResponseTable;

// Manages resources on a specific sysmem heap.
//
// Needs Layout = "Simple" because used with "FIDL Simple C Bindings".
class Heap final {
 public:

  struct AllocateVmoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::vmo vmo;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapAllocateVmoResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AllocateVmoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t size;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = AllocateVmoResponse;
  };

  struct CreateResourceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t id;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapCreateResourceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct CreateResourceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo vmo;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_HeapCreateResourceRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = CreateResourceResponse;
  };

  using DestroyResourceResponse = ::fidl::AnyZeroArgMessage;
  struct DestroyResourceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t id;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    zx_status_t AllocateVmo(uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    zx_status_t CreateResource(::zx::vmo vmo, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CreateResourceResponse> CreateResource(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CreateResourceResponse> CreateResource(::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer);

    // Destroy previously created resources.
    zx_status_t DestroyResource(uint64_t id);

    // Destroy previously created resources.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DestroyResourceResponse> DestroyResource(::fidl::BytePart _request_buffer, uint64_t id);

    // Destroy previously created resources.
    // Messages are encoded and decoded in-place.
    zx_status_t DestroyResource(::fidl::DecodedMessage<DestroyResourceRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    static zx_status_t AllocateVmo(zx::unowned_channel _client_end, uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo);

    // Request a new memory allocation of `size` on heap.
    // For heaps which don't permit CPU access to the buffer data, this
    // will create a VMO with an official size, but which never has any
    // physical pages.  For such heaps, the VMO is effectively used as
    // an opaque buffer identifier.
    //
    // Heaps should defer allocation of any associated resources until
    // CreateResource(), because the caller of AllocateVmo() may simply
    // delete the returned VMO with no further notification to the heap.
    // In contrast, after CreateResource(), the caller guarantees that
    // DestroyResource() or heap channel closure will occur.
    //
    // The caller guarantees that CreateResource() will be called prior
    // to the returned VMO or any associated child VMO being used.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AllocateVmoResponse> AllocateVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    static zx_status_t CreateResource(zx::unowned_channel _client_end, ::zx::vmo vmo, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CreateResourceResponse> CreateResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id);

    // Create resources and associate heap-specific resources with the
    // passed-in VMO. Resources can be hardware specific and their
    // lifetime don't have to be tied to `vmo`. `vmo` must be a VMO
    // (or a direct or indirect child of a VMO) acquired through a call
    // to AllocateVmo method above.  If the passed-in vmo is a child VMO,
    // its size must match the size of the parent VMO created by
    // AllocateVmo().  For heaps that permit CPU access, the passed-in
    // VMO must not have a copy-on-write relationship with the parent
    // VMO, but rather a pass-through relationship. Successful return
    // status indicate that Heap has established a mapping between
    // VMO and hardware specific resources.
    //
    // The returned id must be passed to DestroyResource() later when
    // resources associated with VMO are no longer needed, unless the
    // heap channel closes first.
    //
    // The heap must not own/keep a handle to VMO, or any derived child
    // VMO, or any VMAR mapping to VMO, as any of those would keep VMO
    // alive beyond all sysmem participant usages of the vmo; instead
    // the heap can get the vmo's koid for the heap's mapping.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CreateResourceResponse> CreateResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer);

    // Destroy previously created resources.
    static zx_status_t DestroyResource(zx::unowned_channel _client_end, uint64_t id);

    // Destroy previously created resources.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DestroyResourceResponse> DestroyResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id);

    // Destroy previously created resources.
    // Messages are encoded and decoded in-place.
    static zx_status_t DestroyResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyResourceRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Heap;
    using _Base = ::fidl::CompleterBase;

    class AllocateVmoCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::vmo vmo);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::vmo vmo);
      void Reply(::fidl::DecodedMessage<AllocateVmoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AllocateVmoCompleter = ::fidl::Completer<AllocateVmoCompleterBase>;

    virtual void AllocateVmo(uint64_t size, AllocateVmoCompleter::Sync _completer) = 0;

    class CreateResourceCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t id);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t id);
      void Reply(::fidl::DecodedMessage<CreateResourceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateResourceCompleter = ::fidl::Completer<CreateResourceCompleterBase>;

    virtual void CreateResource(::zx::vmo vmo, CreateResourceCompleter::Sync _completer) = 0;

    class DestroyResourceCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DestroyResourceCompleter = ::fidl::Completer<DestroyResourceCompleterBase>;

    virtual void DestroyResource(uint64_t id, DestroyResourceCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorConnectRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;

// Once a channel with this interface is established to a driver (typically in
// advance), this interface allows asynchronously sending the server end of an
// Allocator channel which will be served by the driver.
//
// For now, the only FIDL interface directly served via normal devhost FIDL
// dispatching code by the sysmem driver is this interface.  Other sysmem
// interfaces are served by separate dispatching code primarily because we want
// to be able to establish channels async by sending the server channel toward
// the driver without needing a round-trip open and without managing the channel
// as a file descriptor.
//
// A secondary current reason tracked by ZX-3091 is that the current devhost
// dispatching code doesn't permit async processing of requests, which we want
// for proper functionining of at least the BufferCollection interface since
// that interface has requests that don't complete until the devhost has
// constraints from other participants.
class DriverConnector final {
 public:
  static constexpr char Name_[] = "fuchsia.sysmem.DriverConnector";

  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel allocator_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_DriverConnectorConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct GetProtectedMemoryInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t base_address;
    uint64_t size;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetProtectedMemoryInfoRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    zx_status_t Connect(::zx::channel allocator_request);

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Connect(::fidl::BytePart _request_buffer, ::zx::channel allocator_request);

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    // Messages are encoded and decoded in-place.
    zx_status_t Connect(::fidl::DecodedMessage<ConnectRequest> params);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    zx_status_t GetProtectedMemoryInfo(int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    static zx_status_t Connect(zx::unowned_channel _client_end, ::zx::channel allocator_request);

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request);

    // This one-way message sends in the server end of an Allocator channel.
    //
    // `allocator_request` will be served by the sysmem driver (or the channel
    // will close).
    // Messages are encoded and decoded in-place.
    static zx_status_t Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    static zx_status_t GetProtectedMemoryInfo(zx::unowned_channel _client_end, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size);

    // Get information about the physical layout of protected memory, for use by sysmem-assistant.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetProtectedMemoryInfoResponse> GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DriverConnector;
    using _Base = ::fidl::CompleterBase;

    using ConnectCompleter = ::fidl::Completer<>;

    virtual void Connect(::zx::channel allocator_request, ConnectCompleter::Sync _completer) = 0;

    class GetProtectedMemoryInfoCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t base_address, uint64_t size);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t base_address, uint64_t size);
      void Reply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetProtectedMemoryInfoCompleter = ::fidl::Completer<GetProtectedMemoryInfoCompleterBase>;

    virtual void GetProtectedMemoryInfo(GetProtectedMemoryInfoCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;

// Allocates system memory buffers.
//
class Allocator final {
 public:
  static constexpr char Name_[] = "fuchsia.sysmem.Allocator";

  struct AllocateNonSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel collection;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct AllocateSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel token_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct BindSharedCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel token;
    ::zx::channel buffer_collection_request;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    zx_status_t AllocateNonSharedCollection(::zx::channel collection);

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateNonSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel collection);

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    // Messages are encoded and decoded in-place.
    zx_status_t AllocateNonSharedCollection(::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    zx_status_t AllocateSharedCollection(::zx::channel token_request);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token_request);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    // Messages are encoded and decoded in-place.
    zx_status_t AllocateSharedCollection(::fidl::DecodedMessage<AllocateSharedCollectionRequest> params);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    zx_status_t BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t BindSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    // Messages are encoded and decoded in-place.
    zx_status_t BindSharedCollection(::fidl::DecodedMessage<BindSharedCollectionRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::zx::channel collection);

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection);

    // Allocates a BufferCollection on behalf of a single client (aka initiator)
    // who is also the only participant (from the point of view of sysmem).
    //
    // This call exists mainly for temp/testing purposes.  This call skips the
    // BufferCollectionToken stage, so there's no way to allow another
    // participant to specify its constraints.
    //
    // Real clients are encouraged to use AllocateSharedCollection() instead,
    // and to let relevant participants directly convey their own constraints to
    // sysmem.
    //
    // `constraints` indicates constraints on the buffer collection, such as how
    // many buffers to allocate, buffer size constraints, etc.
    //
    // `collection` is the server end of the BufferCollection FIDL channel.  The
    // client can call SetConstraints() and then WaitForBuffersAllocated() on
    // the client end of this channel to specify constraints and then determine
    // success/failure and get the BufferCollectionInfo_2 for the
    // BufferCollection.  The client should also keep the client end of
    // this channel open while using the BufferCollection, and should notice
    // when this channel closes and stop using the BufferCollection ASAP.
    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::zx::channel token_request);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request);

    // Creates a logical BufferCollectionToken which can be shared among
    // participants (using BufferCollectionToken.Duplicate()), and then
    // converted into a BufferCollection using BindSharedCollection().
    //
    // Success/failure to populate the BufferCollection with buffers is
    // determined via the BufferCollection interface.
    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSharedCollectionRequest> params);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request);

    // Convert a BufferCollectionToken into a connection to the logical
    // BufferCollection.  The BufferCollection hasn't yet been populated with
    // buffers - the participant must first also send SetConstraints() via the
    // client end of buffer_collection.
    //
    // All BufferCollectionToken(s) duplicated from a logical
    // BufferCollectionToken created via AllocateSharedCollection() must be
    // turned in via BindSharedCollection() before the logical BufferCollection
    // will be populated with buffers.
    //
    // `token` the client endpoint of a channel whose server end was sent to
    // sysmem using AllocateSharedCollection or whose server end was sent to
    // sysmem using BufferCollectionToken.Duplicate().  The token is being
    // "exchanged" for a channel to the logical BufferCollection.
    //
    // `buffer_collection` the server end of a BufferCollection channel.  The
    // sender retains the client end as usual.  The BufferCollection channel
    // is a single participant's connection to the logical BufferCollection.
    // There typically will be other participants with their own
    // BufferCollection channel to the logical BufferCollection.
    // Messages are encoded and decoded in-place.
    static zx_status_t BindSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindSharedCollectionRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Allocator;
    using _Base = ::fidl::CompleterBase;

    using AllocateNonSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void AllocateNonSharedCollection(::zx::channel collection, AllocateNonSharedCollectionCompleter::Sync _completer) = 0;

    using AllocateSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void AllocateSharedCollection(::zx::channel token_request, AllocateSharedCollectionCompleter::Sync _completer) = 0;

    using BindSharedCollectionCompleter = ::fidl::Completer<>;

    virtual void BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request, BindSharedCollectionCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct ImagePlane {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Byte offset of the start of the plane from the beginning of the image.
  uint32_t byte_offset{};

  // Stride in bytes per row.
  // Only meaningful for linear buffer formats.
  uint32_t bytes_per_row{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferMemoryConstraintsTable;

struct BufferMemoryConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferMemoryConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 280;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t min_size_bytes{};

  uint32_t max_size_bytes{};

  bool physically_contiguous_required{};

  // If true, at least one participant requires secure memory.
  //
  // When aggregating BufferCollectionConstraints, these values boolean-OR.
  bool secure_required{};

  // By default, participants must ensure the CPU can read or write data to
  // the buffer without cache operations. If they support using the RAM
  // domain, data must be available in RAM (with CPU cache state such that
  // the RAM data won't get corrupted by a dirty CPU cache line writing
  // incorrect data to RAM), and a consumer reading using the CPU must
  // invalidate CPU cache before reading (the producer doesn't guarantee
  // zero stale "clean" cache lines)
  bool ram_domain_supported{};

  bool cpu_domain_supported{};

  bool inaccessible_domain_supported{};

  // Optional heap constraints. Participants that don't care which heap
  // memory is allocated on should leave this field 0.
  uint32_t heap_permitted_count{};

  ::fidl::Array<HeapType, 32> heap_permitted{};
};



struct FormatModifier {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The upper 8 bits are a vendor code as allocated in FormatModifierVendor
  // enum.  The lower 56 bits are vendor-defined.
  //
  // This field and the values that go in this field are defined this way for
  // compatibility reasons.
  uint64_t value{};
};

extern "C" const fidl_type_t fuchsia_sysmem_PixelFormatTable;

// Describes how the pixels within an image are represented.
// Simple formats need only a type.
// Parametric pixel formats may require additional properties.
struct PixelFormat {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_PixelFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  PixelFormatType type{};

  // This bool effectively makes format_modifier optional, to satisfy
  // 'Layout = "Simple"', to satisify "FIDL Simple C Bindings".
  bool has_format_modifier{};

  FormatModifier format_modifier{};
};

constexpr uint64_t FORMAT_MODIFIER_VENDOR_VIVANTE = 432345564227567616u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_SAMSUNG = 288230376151711744u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_QCOM = 360287970189639680u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_NVIDIA = 216172782113783808u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_NONE = 0u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_INTEL = 72057594037927936u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_BROADCOM = 504403158265495552u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_ARM = 576460752303423488u;

constexpr uint64_t FORMAT_MODIFIER_VENDOR_AMD = 144115188075855872u;

constexpr uint64_t FORMAT_MODIFIER_VALUE_RESERVED = 72057594037927935u;

constexpr uint64_t FORMAT_MODIFIER_INVALID = FORMAT_MODIFIER_VALUE_RESERVED;

constexpr uint64_t FORMAT_MODIFIER_NONE = 0u;

constexpr uint64_t FORMAT_MODIFIER_LINEAR = 0u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_Y_TILED = 72057594037927938u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_YF_TILED = 72057594037927939u;

constexpr uint64_t FORMAT_MODIFIER_INTEL_I915_X_TILED = 72057594037927937u;

constexpr uint64_t FORMAT_MODIFIER_ARM_AFBC_32x8 = 576460752303423490u;

constexpr uint64_t FORMAT_MODIFIER_ARM_AFBC_16x16 = 576460752303423489u;



// Describes how the pixels within an image are meant to be presented.
// Simple color spaces need only a type.
// Parametric color spaces may require additional properties.
struct ColorSpace {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ColorSpaceType type{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageSpecTable;

// Describes constraints for allocating images of some desired form.
struct ImageSpec {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageSpecTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Minimum width in pixels.
  uint32_t min_width{};

  // Minimum height in pixels.
  uint32_t min_height{};

  // Number of layers within a multi-layered image.
  // Defaults to 1 if not specified.
  uint32_t layers{};

  // Pixel format.
  PixelFormat pixel_format{};

  // Color space.
  ColorSpace color_space{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferSpecTable;

// Describes constraints for allocating buffers of some desired form.
// Buffers of each type are described by their own tables.
struct BufferSpec {
  enum class Tag : fidl_union_tag_t {
    kImage = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  BufferSpec();
  ~BufferSpec();

  BufferSpec(BufferSpec&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  BufferSpec& operator=(BufferSpec&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_image() const { return tag_ == Tag::kImage; }

  ImageSpec& mutable_image();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageSpec>::value && std::is_copy_assignable<T>::value>
  set_image(const T& v) {
    mutable_image() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageSpec>::value && std::is_move_assignable<T>::value>
  set_image(T&& v) {
    mutable_image() = std::move(v);
  }

  ImageSpec const & image() const { return image_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferSpecTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(BufferSpec&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    ImageSpec image_;
  };
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormat_2Table;

// Describes how an image is represented.
struct ImageFormat_2 {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormat_2Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Pixel format.
  PixelFormat pixel_format{};

  // Row width in pixels that exist in the buffer.  Must be >= display_width.
  // Can be < the width implied by stride_bytes.
  uint32_t coded_width{};

  // Number of rows.  Must be >= display_height.
  uint32_t coded_height{};

  uint32_t bytes_per_row{};

  // Row width in pixels that are to be displayed.  This can be <=
  // coded_width.  Any cropping occurs on the right of the image (not left).
  uint32_t display_width{};

  // Number of rows to be displayed.  This can be <= coded_height, with any
  // cropping on the bottom (not top).
  uint32_t display_height{};

  // Number of layers within a multi-layered image.
  uint32_t layers{};

  // Color space.
  ColorSpace color_space{};

  // The pixel_aspect_ratio_width : pixel_aspect_ratio_height is the
  // pixel aspect ratio (AKA sample aspect ratio aka SAR) for the luma
  // (AKA Y) samples. A pixel_aspect_ratio of 1:1 mean square pixels. A
  // pixel_aspect_ratio of 2:1 would mean pixels that are displayed twice
  // as wide as they are tall. Codec implementation should ensure these
  // two values are relatively prime by reducing the fraction (dividing
  // both by GCF) if necessary.
  //
  // When has_pixel_aspect_ratio == false, pixel_aspect_ratio_width and
  // pixel_aspect_ratio_height will both be 1, but in that case the
  // pixel_aspect_ratio_width : pixel_aspect_ratio_height of 1:1 is just
  // a very weak suggestion re. reasonable-ish handling, not in any way
  // authoritative. In this case (or in any case really) the receiver of
  // this message may have other OOB means to determine the actual
  // pixel_aspect_ratio.
  bool has_pixel_aspect_ratio{};

  uint32_t pixel_aspect_ratio_width{};

  uint32_t pixel_aspect_ratio_height{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormatConstraintsTable;

// Describes constraints on layout of image data in buffers.
struct ImageFormatConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormatConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 232;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The PixelFormat for which the following constraints apply.  A
  // participant may have more than one PixelFormat that's supported, in
  // which case that participant can use a list of ImageFormatConstraints
  // with an entry per PixelFormat.  It's not uncommon for the other fields
  // of ImageFormatConstraints to vary by PixelFormat - for example for a
  // linear format to support smaller max size than a tiled format.
  PixelFormat pixel_format{};

  // Empty is an error.  Redundant entries are an error.  Arbitrary ordering
  // is not an error.
  uint32_t color_spaces_count{};

  ::fidl::Array<ColorSpace, 32> color_space{};

  // Minimum permitted width in pixels.
  //
  // For example a video decoder participant may set this field to the
  // minimum coded_width that might potentially be specified by a stream.  In
  // contrast, required_min_coded_width would be set to the current
  // coded_width specified by the stream.  While min_coded_width aggregates
  // by taking the max, required_min_coded_width aggregates by taking the
  // min.
  //
  // See also required_min_coded_width.
  uint32_t min_coded_width{};

  // Maximum width in pixels.  For example Scenic may set this field
  // (directly or via sub-participants) to the maximum width that can be
  // composited.
  uint32_t max_coded_width{};

  // Minimum height in pixels.  For example a video decoder participant may
  // set this field to the coded_height specified by a stream.
  uint32_t min_coded_height{};

  // Maximum height in pixels.  For example Scenic may set this field
  // (directly or via sub-participants) to the maximum height that can be
  // composited.
  uint32_t max_coded_height{};

  // Must be >= the value implied by min_coded_width for plane 0.
  uint32_t min_bytes_per_row{};

  // Must be >= the value implied by max_coded_width for plane 0.
  uint32_t max_bytes_per_row{};

  // The max image area in pixels is limited indirectly via
  // BufferSettings.size_bytes, and can also be enforced directly via this
  // field.
  uint32_t max_coded_width_times_coded_height{};

  // Number of layers within a multi-layered image.
  // Defaults to 1 if not specified.
  uint32_t layers{};

  // coded_width % width_divisor must be 0.
  uint32_t coded_width_divisor{};

  // coded_height % height_divisor must be 0.
  uint32_t coded_height_divisor{};

  // bytes_per_row % bytes_per_row_divisor must be 0.
  uint32_t bytes_per_row_divisor{};

  // vmo_usable_start % start_offset_divisor must be 0.
  uint32_t start_offset_divisor{};

  // display_width % display_width_divisor must be 0.
  uint32_t display_width_divisor{};

  // display_height % display_height_divisor must be 0.
  uint32_t display_height_divisor{};

  // required_ dimension bounds.
  //
  // In contrast to the corresponding fields without "required_" at the
  // start, these fields (when set to non-zero values) express a requirement
  // that the resulting aggregated non-required_ fields specify a space that
  // fully contain the space expressed by each participant's required_
  // fields.
  //
  // For example, a producer video decoder is perfectly happy for the
  // consumer to be willing to accept anything, and the video decoder doesn't
  // really want to constrain the potential space of dimensions that might be
  // seen in a stream and may be acceptable to the consumer, but the video
  // decoder needs to ensure that the resulting dimension ranges contain
  // at least the current dimensions decoded from the stream.
  //
  // Similarly, an initiator with a particular dynamic-dimension scenario in
  // mind may wish to require up front that participants agree to handle at
  // least the range of dimensions expected by the initiator in that
  // scenario (else fail earlier rather than later, maybe trying again with
  // smaller required_ space).
  //
  // It's much more common for a producer or initiator to set these fields
  // than for a consumer to set these fields.
  //
  // While the non-required_ fields aggregate by taking the intersection, the
  // required_ fields aggregate by taking the union.
  uint32_t required_min_coded_width{};

  uint32_t required_max_coded_width{};

  uint32_t required_min_coded_height{};

  uint32_t required_max_coded_height{};

  uint32_t required_min_bytes_per_row{};

  uint32_t required_max_bytes_per_row{};
};

extern "C" const fidl_type_t fuchsia_sysmem_ImageFormatTable;

// Describes how an image is represented.
struct ImageFormat {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_ImageFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 72;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Row width in pixels.
  uint32_t width{};

  // Number of rows.
  uint32_t height{};

  // Number of layers within a multi-layered image.
  // Defaults to 1 if not specified.
  uint32_t layers{};

  // Pixel format.
  PixelFormat pixel_format{};

  // Color space.
  ColorSpace color_space{};

  ::fidl::Array<ImagePlane, 4> planes{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferFormatTable;

// Describes how the contents of buffers are represented.
// Buffers of each type are described by their own tables.
struct BufferFormat {
  enum class Tag : fidl_union_tag_t {
    kImage = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  BufferFormat();
  ~BufferFormat();

  BufferFormat(BufferFormat&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  BufferFormat& operator=(BufferFormat&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_image() const { return tag_ == Tag::kImage; }

  ImageFormat& mutable_image();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageFormat>::value && std::is_copy_assignable<T>::value>
  set_image(const T& v) {
    mutable_image() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ImageFormat>::value && std::is_move_assignable<T>::value>
  set_image(T&& v) {
    mutable_image() = std::move(v);
  }

  ImageFormat const & image() const { return image_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferFormatTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(BufferFormat&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    ImageFormat image_;
  };
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionInfoTable;

// Information about a buffer collection and its buffers.
struct BufferCollectionInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionInfoTable;
  static constexpr uint32_t MaxNumHandles = 64;
  static constexpr uint32_t PrimarySize = 352;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The number of buffers in the collection.
  uint32_t buffer_count{};

  // Describes how the contents of buffers are represented.
  // All buffers within the collection have the same format.
  BufferFormat format{};

  // VMO handles for each buffer in the collection.
  // The VMOs are only present when the buffers are backed by VMOs.
  //
  // If present, all the VMOs after `buffer_count` are invalid handles.
  // All buffer VMO handles have identical size and access rights.
  // The VMO access rights are determined based on the usages which the
  // client specified when allocating the buffer collection.  For example,
  // a client which expressed a read-only usage will receive VMOs without
  // write rights.
  ::fidl::Array<::zx::vmo, 64> vmos{};

  // The size of each VMO provided.
  // This property is only present when the buffers are backed by VMOs.
  uint64_t vmo_size{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferMemorySettingsTable;

struct BufferMemorySettings {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferMemorySettingsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t size_bytes{};

  bool is_physically_contiguous{};

  bool is_secure{};

  CoherencyDomain coherency_domain{};

  // The specific heap from which buffers are allocated.
  // See above in this file for heap identifier values.
  HeapType heap{};
};

extern "C" const fidl_type_t fuchsia_sysmem_SingleBufferSettingsTable;

// After the initial buffer allocation, it's allowed to close old buffers and
// allocate new buffers.  When a new buffer is allocated its settings can differ
// from the rest of the buffers in the collection, and the single buffer's
// settings are delivered via OnSingleBufferAllocated() using this struct:
struct SingleBufferSettings {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_SingleBufferSettingsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 264;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  BufferMemorySettings buffer_settings{};

  // Buffers holding data that is not uncompressed image data will not have
  // this field set.  Buffers holding data that is uncompressed image data
  // _may_ have this field set.
  //
  // At least for now, changing the PixelFormat requires re-allocating
  // buffers.
  bool has_image_format_constraints{};

  ImageFormatConstraints image_format_constraints{};
};

extern "C" const fidl_type_t fuchsia_sysmem_SingleBufferInfoTable;

struct SingleBufferInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_SingleBufferInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 280;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  SingleBufferSettings settings{};

  VmoBuffer buffer{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionInfo_2Table;

// Information about a buffer collection and its buffers.
struct BufferCollectionInfo_2 {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionInfo_2Table;
  static constexpr uint32_t MaxNumHandles = 64;
  static constexpr uint32_t PrimarySize = 1296;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // If this is the initial buffer collection allocation, this is the total
  // number of buffers.  If this is a single buffer allocation, this is zero,
  // and the rest of the fields only apply to the single buffer.
  uint32_t buffer_count{};

  // These settings apply to all the buffers in the inital buffer allocation.
  SingleBufferSettings settings{};

  // VMO handles (and vmo_usable_start offset) for each buffer in the
  // collection.
  //
  // If present, all the VMOs at or after index `buffer_count` are invalid (0)
  // handles.
  //
  // All buffer VMO handles have identical size and access rights.  The size
  // is in settings.buffer_settings.size_bytes.
  //
  // The VMO access rights are determined based on the usages which the
  // client specified when allocating the buffer collection.  For example,
  // a client which expressed a read-only usage will receive VMOs without
  // write rights.  In addition, the rights can be attenuated by the parameter
  // to BufferCollectionToken.Duplicate() calls.
  ::fidl::Array<VmoBuffer, 64> buffers{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;

// This interface intentionally doesn't include any event for
// OnOldBufferClosed(), because such an event could arrive at a participant too
// soon to be useful.  Instead, such an indication should be made in-band within
// FIDL interfaces that deliver packets to downstream participants.
class BufferCollectionEvents final {
 public:
  static constexpr char Name_[] = "fuchsia.sysmem.BufferCollectionEvents";

  using OnDuplicatedTokensKnownByServerRequest = ::fidl::AnyZeroArgMessage;

  struct OnBuffersAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    BufferCollectionInfo_2 buffer_collection_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
    static constexpr uint32_t MaxNumHandles = 64;
    static constexpr uint32_t PrimarySize = 1320;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct OnAllocateSingleBufferDoneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    SingleBufferInfo buffer_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 304;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // See comments on BufferCollectionToken::Sync().
    //
    // This message only indicates that the server has reached the point where
    // it knows about previously created tokens Duplicate()ed from the token
    // used to create this BufferCollection.
    zx_status_t OnDuplicatedTokensKnownByServer();

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    zx_status_t OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t OnBuffersAllocated(::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    // Messages are encoded and decoded in-place.
    zx_status_t OnBuffersAllocated(::fidl::DecodedMessage<OnBuffersAllocatedRequest> params);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    zx_status_t OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t OnAllocateSingleBufferDone(::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    // Messages are encoded and decoded in-place.
    zx_status_t OnAllocateSingleBufferDone(::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // See comments on BufferCollectionToken::Sync().
    //
    // This message only indicates that the server has reached the point where
    // it knows about previously created tokens Duplicate()ed from the token
    // used to create this BufferCollection.
    static zx_status_t OnDuplicatedTokensKnownByServer(zx::unowned_channel _client_end);

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);

    // This event inidicates that buffer allocation is over, whether succesful
    // or failed.
    //
    // This event will eventually be sent by the server (unless the
    // BufferCollection channel closes first).
    //
    // `status`:
    // `ZX_OK` if successful.
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    //
    // `buffer_collection_info` The buffer information, including VMO handles.
    // If `status` is not `ZX_OK`, `buffer_collection_info` is default
    // initialized and contains no meaningful information.
    // Messages are encoded and decoded in-place.
    static zx_status_t OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnBuffersAllocatedRequest> params);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, int32_t status, SingleBufferInfo buffer_info);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info);

    // A participant can learn when a new buffer is allocated via this event.
    // The only participant that will see a failing status is the participant
    // that attempted the single buffer allocation.  Other participants will
    // only see successful single buffer allocations.
    //
    // `status`:
    //
    // `ZX_OK` if successful.  This can be seen by any participant (whether
    // sender of AllocateSingleBuffer() or not.)
    //
    // `ZX_ERR_NOT_FOUND` if the buffer_index sent via
    // CheckSingleBufferAllocated() isn't known to the server.  This can be seen
    // by any participant (whether sender of AllocateSingleBuffer() or not.)
    //
    // These error codes are only ever seen by the sender of
    // AllocateSingleBuffer():
    //
    // `ZX_ERR_NO_MEMORY` if the request is valid but cannot be fulfilled due to
    // resource exhaustion.
    // `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to obtain the
    // buffers it requested.
    // `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be satisfied,
    // perhaps due to hardware limitations.
    // Messages are encoded and decoded in-place.
    static zx_status_t OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollectionEvents;
    using _Base = ::fidl::CompleterBase;

    using OnDuplicatedTokensKnownByServerCompleter = ::fidl::Completer<>;

    virtual void OnDuplicatedTokensKnownByServer(OnDuplicatedTokensKnownByServerCompleter::Sync _completer) = 0;

    using OnBuffersAllocatedCompleter = ::fidl::Completer<>;

    virtual void OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info, OnBuffersAllocatedCompleter::Sync _completer) = 0;

    using OnAllocateSingleBufferDoneCompleter = ::fidl::Completer<>;

    virtual void OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info, OnAllocateSingleBufferDoneCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct BufferUsage {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t cpu{};

  uint32_t vulkan{};

  uint32_t display{};

  uint32_t video{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionConstraintsTable;

// Constraints on BufferCollection parameters.  These constraints can be
// specified per-participant.  The sysmem service implements aggregation of
// constraints from multiple participants.
struct BufferCollectionConstraints {
  static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionConstraintsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 7752;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The usage is only meant as a hint to help sysmem choose a more optimal
  // PixelFormat or similar when multiple compatible options exist.
  //
  // When aggregating BufferCollectionConstraints, these values bitwise-OR.
  //
  // At least one usage bit must be specified unless the whole
  // BufferCollectionConstraints is logically null due to !has_constraints.
  BufferUsage usage{};

  // Per-participant minimum number of buffers that are needed for camping
  // purposes.  A participant should specify a number for min_buffer_count
  // that's >= the maximum number of buffers that the participant may
  // concurrently camp on for any non-transient period of time.
  //
  // For example, a video decoder would specify (at least) the maximum number
  // of reference frames + 1 frame currently being decoded into.
  //
  // A participant must not camp on more buffers than specified here (except
  // very transiently) else processing may get stuck.
  //
  // When aggregating BufferCollectionConstraints, these values add.
  //
  // In testing scenarios, camping on more buffers than this for any
  // significant duration may (ideally will) be flagged as a failure.  In
  // testing scenarios, the participant may not be provided with more buffers
  // than this concurrently.
  uint32_t min_buffer_count_for_camping{};

  // Per-participant minimum number of buffers that are needed for slack
  // reasons, for better overlap of processing / better performance.
  //
  // When aggregating BufferCollectionConstraints, these values add.
  //
  // A participant should typically specify 0 or 1 here - typically 0 is
  // appropriate if min_buffer_count_for_camping is already enough to keep
  // the participant busy 100% of the time when the participant is slightly
  // behind, while 1 can be appropriate if 1 more buffer than strictly needed
  // for min-camping reasons gives enough slack to stay busy 100% of the time
  // (when slightly behind, vs. lower % without the extra buffer).
  //
  // In testing scenarios, this field may be forced to 0, and all
  // participants are expected to continue to work without getting stuck.  If
  // a buffer is needed for forward progress reasons, that buffer should be
  // accounted for in min_buffer_count_for_camping.
  uint32_t min_buffer_count_for_dedicated_slack{};

  // Similar to min_buffer_count_for_dedicated_slack, except when aggregating
  // these values max (instead of add).  The value here is not shared with
  // any participant's min_buffer_count_for_dedicated_slack.
  //
  // A participant can specify > 0 here if a participant would like to ensure
  // there's some slack overall, but doesn't need that slack to be dedicated.
  //
  // The choice whether to use min_buffer_count_for_dedicated_slack or
  // min_buffer_count_for_shared_slack (or both) will typically be about the
  // degree to which the extra slack improves performance.
  //
  // In testing scenarios, this field may be forced to 0, and all
  // participants are expected to continue to work without getting stuck.  If
  // a buffer is needed for forward progress reasons, that buffer should be
  // accounted for in min_buffer_count_for_camping.
  uint32_t min_buffer_count_for_shared_slack{};

  // A particularly-picky participant may unfortunately need to demand a tight
  // range of buffer_count, or even a specific buffer_count.  This field
  // should remain 0 unless a participant really must set this field to
  // constrain the overall BufferCollectionInfo_2.buffer_count.  Any such
  // participant should still fill out the min_buffer_count_for_* fields
  // above.
  uint32_t min_buffer_count{};

  // 0 is treated as 0xFFFFFFFF.
  uint32_t max_buffer_count{};

  // Constraints on BufferCollectionSettings.buffer_settings.
  //
  // A participant that intends to specify image_format_constraints_count > 1
  // will typically specify the minimum buffer size implicitly via
  // image_format_constraints, and possibly specify only the max buffer size
  // via buffer_memory_constraints.
  bool has_buffer_memory_constraints{};

  BufferMemoryConstraints buffer_memory_constraints{};

  // Optional constraints on the image format parameters of an image stored
  // in a buffer of the BufferCollection.  This includes pixel format and
  // image layout.  These constraints are per-pixel-format, so more than one
  // is permitted.
  //
  // When aggregating, only pixel formats that are specified by all
  // particpants with non-zero image_format_constraints_count (and non-Null)
  // BufferCollectionConstraints) are retained.
  uint32_t image_format_constraints_count{};

  ::fidl::Array<ImageFormatConstraints, 32> image_format_constraints{};
};

extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;

// BufferCollection is a connection directly from a participant to sysmem re.
// a logical BufferCollection; typically the logical BufferCollection is shared
// with other participants.  In other words, an instance of the BufferCollection
// interface is a view of a "LogicalBufferCollection".
//
// This connection exists to facilitate async indication of when the logical
// BufferCollection has been populated with buffers.
//
// Also, the channel's closure by the server is an indication to the client
// that the client should close all VMO handles that were obtained from the
// BufferCollection ASAP.
//
// Also, this interface may in future allow specifying constraints in other
// ways, and may allow for back-and-forth negotiation of constraints to some
// degree.
//
// This interface may in future allow for more than 64 VMO handles per
// BufferCollection, but currently the limit is 64.
//
// This interface may in future allow for allocating/deallocating single
// buffers.
//
// Some initiators may wait a short duration until all old logical
// BufferCollection VMO handles have closed (or until the short duration times
// out) before allocating a new BufferCollection, to help control physical
// memory fragmentation and avoid overlap of buffer allocation lifetimes for
// the old and new collections. Collections can be large enough that it's worth
// avoiding allocation overlap (in time).
class BufferCollection final {
 public:
  static constexpr char Name_[] = "fuchsia.sysmem.BufferCollection";

  struct SetEventSinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel events;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using SyncResponse = ::fidl::AnyZeroArgMessage;
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct SetConstraintsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool has_constraints;
    BufferCollectionConstraints constraints;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 7776;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct WaitForBuffersAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    BufferCollectionInfo_2 buffer_collection_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 64;
    static constexpr uint32_t PrimarySize = 1320;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using WaitForBuffersAllocatedRequest = ::fidl::AnyZeroArgMessage;

  struct CheckBuffersAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CheckBuffersAllocatedRequest = ::fidl::AnyZeroArgMessage;

  struct CloseSingleBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct AllocateSingleBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct WaitForSingleBufferAllocatedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    SingleBufferInfo buffer_info;

    static constexpr const fidl_type_t* Type = &fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 304;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WaitForSingleBufferAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = WaitForSingleBufferAllocatedResponse;
  };

  struct CheckSingleBufferAllocatedRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t buffer_index;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    zx_status_t SetEventSink(::zx::channel events);

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetEventSink(::fidl::BytePart _request_buffer, ::zx::channel events);

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    // Messages are encoded and decoded in-place.
    zx_status_t SetEventSink(::fidl::DecodedMessage<SetEventSinkRequest> params);

    // See comments on BufferCollectionToken::Sync().
    zx_status_t Sync();

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    zx_status_t SetConstraints(bool has_constraints, BufferCollectionConstraints constraints);

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetConstraints(::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints);

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    // Messages are encoded and decoded in-place.
    zx_status_t SetConstraints(::fidl::DecodedMessage<SetConstraintsRequest> params);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    zx_status_t WaitForBuffersAllocated(int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(::fidl::BytePart response_buffer);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    zx_status_t CheckBuffersAllocated(int32_t* out_status);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(::fidl::BytePart response_buffer);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    zx_status_t CloseSingleBuffer(uint64_t buffer_index);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CloseSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    // Messages are encoded and decoded in-place.
    zx_status_t CloseSingleBuffer(::fidl::DecodedMessage<CloseSingleBufferRequest> params);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    zx_status_t AllocateSingleBuffer(uint64_t buffer_index);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t AllocateSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    // Messages are encoded and decoded in-place.
    zx_status_t AllocateSingleBuffer(::fidl::DecodedMessage<AllocateSingleBufferRequest> params);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    zx_status_t WaitForSingleBufferAllocated(uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    zx_status_t CheckSingleBufferAllocated(uint64_t buffer_index);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CheckSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    // Messages are encoded and decoded in-place.
    zx_status_t CheckSingleBufferAllocated(::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params);

    // The server handles unexpected failure of a BufferCollection by failing
    // the whole LogicalBufferCollection.  Partly this is to expedite closing
    // VMO handles.  If a participant would like to cleanly close a
    // BufferCollection view without causing LogicalBufferCollection failure,
    // the participant can send Close() before closing the client end of the
    // BufferCollection channel.  If this is the last BufferCollection view, the
    // LogicalBufferCollection will still go away.
    zx_status_t Close();

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::zx::channel events);

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events);

    // At least for now, the only way to get events from a BufferCollection is
    // to set a reverse BufferCollectionEvents channel.  This can be sent up to
    // once at any point during BufferCollection channel lifetime.  All events
    // are one-shot events, and will be sent immediately via `events` if the
    // one-shot event's condition has already become true (once true will stay
    // true; only goes from false to true once).
    //
    // `events` is the client end of a BufferCollectionEvents which will be sent
    // one-way messages indicating events relevant to this BufferCollection
    // channel (some may be specific to this BufferCollection channel and some
    // may be relevant to the overall logical BufferCollection).
    // Messages are encoded and decoded in-place.
    static zx_status_t SetEventSink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetEventSinkRequest> params);

    // See comments on BufferCollectionToken::Sync().
    static zx_status_t Sync(zx::unowned_channel _client_end);

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    static zx_status_t SetConstraints(zx::unowned_channel _client_end, bool has_constraints, BufferCollectionConstraints constraints);

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints);

    // Provide BufferCollectionConstraints to the logical BufferCollection.
    //
    // Participants with read but not write can only call SetConstraints() once.
    //
    // Participants with write can call SetConstraints() more than once.  The
    // initial buffer allocation will use the constraints in the first call to
    // SetConstraints().  Among other things, this allows a decoder to attempt
    // to allocate a new buffer that's larger to hold an output frame that's
    // larger.
    //
    // Sometimes the initiator is a participant only in the sense of wanting to
    // keep an eye on success/failure to populate with buffers, and zx.status on
    // failure.  In that case, `has_constraints` can be false, and `constraints`
    // will be ignored.
    //
    // VMO handles will not be provided to the client that sends null
    // constraints - that can be intentional for an initiator that doesn't need
    // VMO handles.  Not having VMO handles doesn't prevent the initator from
    // adjusting which portion of a buffer is considered valid and similar, but
    // the initiator can't hold a VMO handle open to prevent the logical
    // BufferCollection from cleaning up if the logical BufferCollection needs
    // to go away regardless of the initiator's degree of involvement for
    // whatever reason.
    //
    // For population of buffers to be attempted, all holders of a
    // BufferCollection client channel need to call SetConstraints() before
    // sysmem will attempt to allocate buffers.
    //
    // `has_constraints` if false, the constraints are effectively null, and
    // `constraints` are ignored.  The sender of null constraints won't get any
    // VMO handles in BufferCollectionInfo, but can still find out how many
    // buffers were allocated and can still refer to buffers by their
    // buffer_index.
    //
    // `constraints` are constraints on the buffer collection.
    // Messages are encoded and decoded in-place.
    static zx_status_t SetConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConstraintsRequest> params);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    static zx_status_t WaitForBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info);

    // This request completes when buffers have been allocated, responds with
    // some failure detail if allocation has been attempted but failed.
    //
    // The following must occur before buffers will be allocated:
    //   * All BufferCollectionToken(s) of the logical BufferCollectionToken
    //     must be turned in via BindSharedCollection().
    //   * All BufferCollection(s) of the logical BufferCollection must have had
    //     SetConstraints() sent to them.
    //
    // A caller using C generated FIDL code who wishes not to block a thread in
    // a zx_channel_call() for a potentially fairly long duration on this
    // message/response can use SetEventSink() and
    // BufferCollectionEvents.OnBuffersPopulated() instead.
    //
    // This method is still legal to call despite use of OnBuffersPopulated(),
    // but in that case the additional BufferCollectionInfo returned here will
    // include handles that are redundant with other handles in the
    // BufferCollectionInfo delivered via OnBuffersPopulated() (separate handle
    // but same underlying VMO objects), so most clients that bother calling
    // SetEventSink() will prefer to receive BufferCollectionInfo via
    // OnBuffersPopulated().  This method is mostly here for clients that don't
    // call SetEventSink().
    //
    // Returns `ZX_OK` if successful.
    // Returns `ZX_ERR_NO_MEMORY` if the request is valid but cannot be
    // fulfilled due to resource exhaustion.
    // Returns `ZX_ERR_ACCESS_DENIED` if the caller is not permitted to
    // obtain the buffers it requested.
    // Returns `ZX_ERR_INVALID_ARGS` if the request is malformed.
    // Returns `ZX_ERR_NOT_SUPPORTED` if request is valid but cannot be
    // satisfied, perhaps due to hardware limitations.
    //
    // `buffer_collection_info` has the VMO handles and other related info.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WaitForBuffersAllocatedResponse> WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    static zx_status_t CheckBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // This returns the same result code as WaitForBuffersAllocated if the
    // buffer collection has been allocated or failed, or `ZX_ERR_UNAVAILABLE`
    // if WaitForBuffersAllocated would block.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CheckBuffersAllocatedResponse> CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // The CloseBuffer() doesn't immediately force all VMO handles to that
    // buffer to close, but it does close any handle held by sysmem, and does
    // notify all participants of the desire to close the buffer at which point
    // each participant that's listening may close their handle to the buffer.
    //
    // Only a particpant with write can do this.  Coordination among multiple
    // participants with write is outside of the scope of this interface.
    //
    // `buffer_index` indicates which buffer to close.  If the buffer is already
    // closed this has no effect (idempotent).
    // Messages are encoded and decoded in-place.
    static zx_status_t CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSingleBufferRequest> params);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // This allocates a new buffer that is consistent with the most recent call
    // to SetConstraints(), if possible.  If not possible, this indicates the
    // failure via OnNewBufferAllocated().
    //
    // Only a participant with write can do this.  Coordination among multiple
    // participants with write is outside the scope of this interface.
    //
    // The participant is (intentionally) never informed of other participant's
    // constraints.
    // Messages are encoded and decoded in-place.
    static zx_status_t AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSingleBufferRequest> params);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    static zx_status_t WaitForSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info);

    // Completes when AllocateBuffer is done.  Callers who wish to avoid
    // blocking a thread while waiting can use OnAllocateSingleBufferDone()
    // instead.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse> WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index);

    // A participant can use this message to have sysmem verify that this
    // buffer_index exists.  This message is intentionally ignored by the
    // server if the buffer_index _does_ exist.  In that case, the client will
    // see OnAllocateSingleBufferDone() soon with status == ZX_OK (if the
    // client hasn't already seen that message).  If on the other hand the
    // buffer_index does not exist, this message causes the server to send
    // OnAllocateSingleBufferDone() with status == ZX_ERR_NOT_FOUND.  A
    // particpant will typically use this when the participant receives a new
    // buffer_index that the participant doesn't yet know about, to ensure that
    // the participant won't be waiting forever for the
    // OnAllocateSingleBufferDone() message regarding this buffer_index.
    // Messages are encoded and decoded in-place.
    static zx_status_t CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params);

    // The server handles unexpected failure of a BufferCollection by failing
    // the whole LogicalBufferCollection.  Partly this is to expedite closing
    // VMO handles.  If a participant would like to cleanly close a
    // BufferCollection view without causing LogicalBufferCollection failure,
    // the participant can send Close() before closing the client end of the
    // BufferCollection channel.  If this is the last BufferCollection view, the
    // LogicalBufferCollection will still go away.
    static zx_status_t Close(zx::unowned_channel _client_end);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = BufferCollection;
    using _Base = ::fidl::CompleterBase;

    using SetEventSinkCompleter = ::fidl::Completer<>;

    virtual void SetEventSink(::zx::channel events, SetEventSinkCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    using SetConstraintsCompleter = ::fidl::Completer<>;

    virtual void SetConstraints(bool has_constraints, BufferCollectionConstraints constraints, SetConstraintsCompleter::Sync _completer) = 0;

    class WaitForBuffersAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status, BufferCollectionInfo_2 buffer_collection_info);
      void Reply(::fidl::BytePart _buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info);
      void Reply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WaitForBuffersAllocatedCompleter = ::fidl::Completer<WaitForBuffersAllocatedCompleterBase>;

    virtual void WaitForBuffersAllocated(WaitForBuffersAllocatedCompleter::Sync _completer) = 0;

    class CheckBuffersAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CheckBuffersAllocatedCompleter = ::fidl::Completer<CheckBuffersAllocatedCompleterBase>;

    virtual void CheckBuffersAllocated(CheckBuffersAllocatedCompleter::Sync _completer) = 0;

    using CloseSingleBufferCompleter = ::fidl::Completer<>;

    virtual void CloseSingleBuffer(uint64_t buffer_index, CloseSingleBufferCompleter::Sync _completer) = 0;

    using AllocateSingleBufferCompleter = ::fidl::Completer<>;

    virtual void AllocateSingleBuffer(uint64_t buffer_index, AllocateSingleBufferCompleter::Sync _completer) = 0;

    class WaitForSingleBufferAllocatedCompleterBase : public _Base {
     public:
      void Reply(int32_t status, SingleBufferInfo buffer_info);
      void Reply(::fidl::BytePart _buffer, int32_t status, SingleBufferInfo buffer_info);
      void Reply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WaitForSingleBufferAllocatedCompleter = ::fidl::Completer<WaitForSingleBufferAllocatedCompleterBase>;

    virtual void WaitForSingleBufferAllocated(uint64_t buffer_index, WaitForSingleBufferAllocatedCompleter::Sync _completer) = 0;

    using CheckSingleBufferAllocatedCompleter = ::fidl::Completer<>;

    virtual void CheckSingleBufferAllocated(uint64_t buffer_index, CheckSingleBufferAllocatedCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

}  // namespace sysmem
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::VmoBuffer> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::VmoBuffer>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::VmoBuffer, vmo) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::VmoBuffer, vmo_usable_start) == 8);
static_assert(sizeof(::llcpp::fuchsia::sysmem::VmoBuffer) == ::llcpp::fuchsia::sysmem::VmoBuffer::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest, rights_attenuation_mask) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionToken::DuplicateRequest, token_request) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Heap::AllocateVmoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Heap::AllocateVmoRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Heap::AllocateVmoRequest)
    == ::llcpp::fuchsia::sysmem::Heap::AllocateVmoRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::AllocateVmoRequest, size) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse)
    == ::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::AllocateVmoResponse, vmo) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Heap::CreateResourceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Heap::CreateResourceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Heap::CreateResourceRequest)
    == ::llcpp::fuchsia::sysmem::Heap::CreateResourceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::CreateResourceRequest, vmo) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse)
    == ::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::CreateResourceResponse, id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Heap::DestroyResourceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Heap::DestroyResourceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Heap::DestroyResourceRequest)
    == ::llcpp::fuchsia::sysmem::Heap::DestroyResourceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Heap::DestroyResourceRequest, id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::DriverConnector::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::DriverConnector::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::DriverConnector::ConnectRequest)
    == ::llcpp::fuchsia::sysmem::DriverConnector::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::DriverConnector::ConnectRequest, allocator_request) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse)
    == ::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, base_address) == 24);
static_assert(offsetof(::llcpp::fuchsia::sysmem::DriverConnector::GetProtectedMemoryInfoResponse, size) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest)
    == ::llcpp::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Allocator::AllocateNonSharedCollectionRequest, collection) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest)
    == ::llcpp::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Allocator::AllocateSharedCollectionRequest, token_request) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest)
    == ::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest, token) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::Allocator::BindSharedCollectionRequest, buffer_collection_request) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ImagePlane> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ImagePlane>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImagePlane, byte_offset) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImagePlane, bytes_per_row) == 4);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ImagePlane) == ::llcpp::fuchsia::sysmem::ImagePlane::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferMemoryConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferMemoryConstraints>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, min_size_bytes) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, max_size_bytes) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, physically_contiguous_required) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, secure_required) == 9);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, ram_domain_supported) == 10);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, cpu_domain_supported) == 11);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, inaccessible_domain_supported) == 12);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, heap_permitted_count) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints, heap_permitted) == 24);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferMemoryConstraints) == ::llcpp::fuchsia::sysmem::BufferMemoryConstraints::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::FormatModifier> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::FormatModifier>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::FormatModifier, value) == 0);
static_assert(sizeof(::llcpp::fuchsia::sysmem::FormatModifier) == ::llcpp::fuchsia::sysmem::FormatModifier::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::PixelFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::PixelFormat>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::PixelFormat, type) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::PixelFormat, has_format_modifier) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::PixelFormat, format_modifier) == 8);
static_assert(sizeof(::llcpp::fuchsia::sysmem::PixelFormat) == ::llcpp::fuchsia::sysmem::PixelFormat::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ColorSpace> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ColorSpace>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ColorSpace, type) == 0);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ColorSpace) == ::llcpp::fuchsia::sysmem::ColorSpace::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ImageSpec> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ImageSpec>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageSpec, min_width) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageSpec, min_height) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageSpec, layers) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageSpec, pixel_format) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageSpec, color_space) == 32);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ImageSpec) == ::llcpp::fuchsia::sysmem::ImageSpec::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferSpec> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferSpec>);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ImageFormat_2> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ImageFormat_2>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, pixel_format) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, coded_width) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, coded_height) == 20);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, bytes_per_row) == 24);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, display_width) == 28);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, display_height) == 32);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, layers) == 36);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, color_space) == 40);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, has_pixel_aspect_ratio) == 44);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, pixel_aspect_ratio_width) == 48);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat_2, pixel_aspect_ratio_height) == 52);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ImageFormat_2) == ::llcpp::fuchsia::sysmem::ImageFormat_2::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ImageFormatConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ImageFormatConstraints>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, pixel_format) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, color_spaces_count) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, color_space) == 20);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, min_coded_width) == 148);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, max_coded_width) == 152);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, min_coded_height) == 156);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, max_coded_height) == 160);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, min_bytes_per_row) == 164);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, max_bytes_per_row) == 168);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, max_coded_width_times_coded_height) == 172);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, layers) == 176);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, coded_width_divisor) == 180);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, coded_height_divisor) == 184);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, bytes_per_row_divisor) == 188);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, start_offset_divisor) == 192);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, display_width_divisor) == 196);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, display_height_divisor) == 200);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_min_coded_width) == 204);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_max_coded_width) == 208);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_min_coded_height) == 212);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_max_coded_height) == 216);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_min_bytes_per_row) == 220);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormatConstraints, required_max_bytes_per_row) == 224);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ImageFormatConstraints) == ::llcpp::fuchsia::sysmem::ImageFormatConstraints::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::ImageFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::ImageFormat>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, width) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, height) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, layers) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, pixel_format) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, color_space) == 32);
static_assert(offsetof(::llcpp::fuchsia::sysmem::ImageFormat, planes) == 36);
static_assert(sizeof(::llcpp::fuchsia::sysmem::ImageFormat) == ::llcpp::fuchsia::sysmem::ImageFormat::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferFormat> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferFormat>);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferCollectionInfo>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo, buffer_count) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo, format) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo, vmos) == 88);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo, vmo_size) == 344);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionInfo) == ::llcpp::fuchsia::sysmem::BufferCollectionInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferMemorySettings> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferMemorySettings>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemorySettings, size_bytes) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemorySettings, is_physically_contiguous) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemorySettings, is_secure) == 5);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemorySettings, coherency_domain) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferMemorySettings, heap) == 16);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferMemorySettings) == ::llcpp::fuchsia::sysmem::BufferMemorySettings::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::SingleBufferSettings> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::SingleBufferSettings>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::SingleBufferSettings, buffer_settings) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::SingleBufferSettings, has_image_format_constraints) == 24);
static_assert(offsetof(::llcpp::fuchsia::sysmem::SingleBufferSettings, image_format_constraints) == 32);
static_assert(sizeof(::llcpp::fuchsia::sysmem::SingleBufferSettings) == ::llcpp::fuchsia::sysmem::SingleBufferSettings::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::SingleBufferInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::SingleBufferInfo>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::SingleBufferInfo, settings) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::SingleBufferInfo, buffer) == 264);
static_assert(sizeof(::llcpp::fuchsia::sysmem::SingleBufferInfo) == ::llcpp::fuchsia::sysmem::SingleBufferInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionInfo_2> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferCollectionInfo_2>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo_2, buffer_count) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo_2, settings) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionInfo_2, buffers) == 272);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionInfo_2) == ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnBuffersAllocatedRequest, buffer_collection_info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionEvents::OnAllocateSingleBufferDoneRequest, buffer_info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferUsage> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferUsage>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferUsage, cpu) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferUsage, vulkan) == 4);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferUsage, display) == 8);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferUsage, video) == 12);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferUsage) == ::llcpp::fuchsia::sysmem::BufferUsage::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollectionConstraints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::sysmem::BufferCollectionConstraints>);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, usage) == 0);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_camping) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_dedicated_slack) == 20);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count_for_shared_slack) == 24);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, min_buffer_count) == 28);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, max_buffer_count) == 32);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, has_buffer_memory_constraints) == 36);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, buffer_memory_constraints) == 40);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, image_format_constraints_count) == 320);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints, image_format_constraints) == 328);
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollectionConstraints) == ::llcpp::fuchsia::sysmem::BufferCollectionConstraints::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::SetEventSinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::SetEventSinkRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::SetEventSinkRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::SetEventSinkRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::SetEventSinkRequest, events) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest, has_constraints) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::SetConstraintsRequest, constraints) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse)
    == ::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForBuffersAllocatedResponse, buffer_collection_info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse)
    == ::llcpp::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::CheckBuffersAllocatedResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::CloseSingleBufferRequest, buffer_index) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::AllocateSingleBufferRequest, buffer_index) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedRequest, buffer_index) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse)
    == ::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::WaitForSingleBufferAllocatedResponse, buffer_info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest)
    == ::llcpp::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::sysmem::BufferCollection::CheckSingleBufferAllocatedRequest, buffer_index) == 16);

}  // namespace fidl
